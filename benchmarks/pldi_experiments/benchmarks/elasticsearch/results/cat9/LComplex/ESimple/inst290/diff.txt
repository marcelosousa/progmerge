Merge Instance for method (Ident "MessageChannelHandler",Ident "messageReceived",[RefType (ClassRefType (ClassType [(Ident "ChannelHandlerContext",[])])),RefType (ClassRefType (ClassType [(Ident "MessageEvent",[])]))])
@Override
 public void messageReceived (ChannelHandlerContext ctx, MessageEvent e) throws Exception
{
  Transports.assertTransportThread();
  Object m = e.getMessage();
  if (!(m instanceof ChannelBuffer))
  {
    ctx.sendUpstream(e);
    return;
  }
  ChannelBuffer buffer = (ChannelBuffer) m;
  int size = buffer.getInt((buffer.readerIndex() - 4));
  transportServiceAdapter.received((size + 6));
  boolean hasMessageBytesToRead = size - NettyHeader.HEADER_SIZE - 6 != 0;
  int markedReaderIndex = buffer.readerIndex();
  int expectedIndexReader = markedReaderIndex + size;
  StreamInput streamIn = ChannelBufferStreamInputFactory.create(buffer, size);
  long requestId = buffer.readLong();
  byte status = buffer.readByte();
  Version version = Version.fromId(buffer.readInt());
  <?HOLE?>
  <?HOLE?>
  <?HOLE?>
  <?HOLE?>
  <?HOLE?>
  <?HOLE?>
}
Edit Base:
Hole 1:
[]: StreamInput wrappedStream;
Hole 2:
[]: if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable())
{
  Compressor compressor;
  try
  {
    compressor = CompressorFactory.compressor(buffer);
  }
  catch (NotCompressedException ex)
  {
    int maxToRead = Math.min(buffer.readableBytes(), 10);
    int offset = buffer.readerIndex();
    StringBuilder sb = new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(buffer.readableBytes()).append("] readable bytes with message size [").append(size).append("] ").append("] are [");
    for (int i = 0 ; i < maxToRead ; i++)
    {
      sb.append(buffer.getByte((offset + i))).append(",");
    }
    sb.append("]");
    throw new IllegalStateException(sb.toString());
  }
  wrappedStream = compressor.streamInput(streamIn);
}
else
{
  wrappedStream = streamIn;
}
Hole 3:
[]: <SKIP>
Hole 4:
[]: wrappedStream.setVersion(version);
Hole 5:
[]: if (TransportStatus.isRequest(status))
{
  String action = handleRequest(ctx.getChannel(), wrappedStream, requestId, version);
  if (buffer.readerIndex() != expectedIndexReader)
  {
    if (buffer.readerIndex() < expectedIndexReader)
    {
      logger.warn("Message not fully read (request) for requestId [{}], action [{}], readerIndex [{}] vs expected [{}]; resetting", requestId, action, buffer.readerIndex(), expectedIndexReader);
    }
    else
    {
      logger.warn("Message read past expected size (request) for requestId=[{}], action [{}], readerIndex [{}] vs expected [{}]; resetting", requestId, action, buffer.readerIndex(), expectedIndexReader);
    }
    buffer.readerIndex(expectedIndexReader);
  }
}
else
{
  TransportResponseHandler handler = transportServiceAdapter.onResponseReceived(requestId);
  if (handler != null)
  {
    if (TransportStatus.isError(status))
    {
      handlerResponseError(wrappedStream, handler);
    }
    else
    {
      handleResponse(ctx.getChannel(), wrappedStream, handler);
    }
  }
  else
  {
    buffer.readerIndex((markedReaderIndex + size));
  }
  if (buffer.readerIndex() != expectedIndexReader)
  {
    if (buffer.readerIndex() < expectedIndexReader)
    {
      logger.warn("Message not fully read (response) for [{}] handler {}, error [{}], resetting", requestId, handler, TransportStatus.isError(status));
    }
    else
    {
      logger.warn("Message read past expected size (response) for [{}] handler {}, error [{}], resetting", requestId, handler, TransportStatus.isError(status));
    }
    buffer.readerIndex(expectedIndexReader);
  }
}
Hole 6:
[]: wrappedStream.close();

Edit A:
Hole 1:
[]: StreamInput wrappedStream;
Hole 2:
[]: if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable())
{
  Compressor compressor;
  try
  {
    compressor = CompressorFactory.compressor(buffer);
  }
  catch (NotCompressedException ex)
  {
    int maxToRead = Math.min(buffer.readableBytes(), 10);
    int offset = buffer.readerIndex();
    StringBuilder sb = new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(buffer.readableBytes()).append("] readable bytes with message size [").append(size).append("] ").append("] are [");
    for (int i = 0 ; i < maxToRead ; i++)
    {
      sb.append(buffer.getByte((offset + i))).append(",");
    }
    sb.append("]");
    throw new IllegalStateException(sb.toString());
  }
  wrappedStream = compressor.streamInput(streamIn);
}
else
{
  wrappedStream = streamIn;
}
Hole 3:
[]: wrappedStream = new FilterStreamInput(wrappedStream, namedWriteableRegistry);
Hole 4:
[]: wrappedStream.setVersion(version);
Hole 5:
[]: if (TransportStatus.isRequest(status))
{
  String action = handleRequest(ctx.getChannel(), wrappedStream, requestId, version);
  if (buffer.readerIndex() != expectedIndexReader)
  {
    if (buffer.readerIndex() < expectedIndexReader)
    {
      logger.warn("Message not fully read (request) for requestId [{}], action [{}], readerIndex [{}] vs expected [{}]; resetting", requestId, action, buffer.readerIndex(), expectedIndexReader);
    }
    else
    {
      logger.warn("Message read past expected size (request) for requestId=[{}], action [{}], readerIndex [{}] vs expected [{}]; resetting", requestId, action, buffer.readerIndex(), expectedIndexReader);
    }
    buffer.readerIndex(expectedIndexReader);
  }
}
else
{
  TransportResponseHandler handler = transportServiceAdapter.onResponseReceived(requestId);
  if (handler != null)
  {
    if (TransportStatus.isError(status))
    {
      handlerResponseError(wrappedStream, handler);
    }
    else
    {
      handleResponse(ctx.getChannel(), wrappedStream, handler);
    }
  }
  else
  {
    buffer.readerIndex((markedReaderIndex + size));
  }
  if (buffer.readerIndex() != expectedIndexReader)
  {
    if (buffer.readerIndex() < expectedIndexReader)
    {
      logger.warn("Message not fully read (response) for [{}] handler {}, error [{}], resetting", requestId, handler, TransportStatus.isError(status));
    }
    else
    {
      logger.warn("Message read past expected size (response) for [{}] handler {}, error [{}], resetting", requestId, handler, TransportStatus.isError(status));
    }
    buffer.readerIndex(expectedIndexReader);
  }
}
Hole 6:
[]: wrappedStream.close();

Edit B:
Hole 1:
[]: StreamInput wrappedStream = null;
Hole 2:
[]: try
{
  if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable())
  {
    Compressor compressor;
    try
    {
      compressor = CompressorFactory.compressor(buffer);
    }
    catch (NotCompressedException ex)
    {
      int maxToRead = Math.min(buffer.readableBytes(), 10);
      int offset = buffer.readerIndex();
      StringBuilder sb = new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(buffer.readableBytes()).append("] readable bytes with message size [").append(size).append("] ").append("] are [");
      for (int i = 0 ; i < maxToRead ; i++)
      {
        sb.append(buffer.getByte((offset + i))).append(",");
      }
      sb.append("]");
      throw new IllegalStateException(sb.toString());
    }
    wrappedStream = compressor.streamInput(streamIn);
  }
  else
  {
    wrappedStream = streamIn;
  }
  wrappedStream.setVersion(version);
  if (TransportStatus.isRequest(status))
  {
    String action = handleRequest(ctx.getChannel(), wrappedStream, requestId, version);
    boolean success = false;
    try
    {
      final int nextByte = wrappedStream.read();
      if (nextByte != -1)
      {
        throw new IllegalStateException("Message not fully read (request) for requestId [" + requestId + "], action [" + action + "], readerIndex [" + buffer.readerIndex() + "] vs expected [" + expectedIndexReader + "]; resetting");
      }
      if (buffer.readerIndex() < expectedIndexReader)
      {
        throw new IllegalStateException("Message is fully read (request), yet there are " + expectedIndexReader - buffer.readerIndex() + " remaining bytes; resetting");
      }
      if (buffer.readerIndex() > expectedIndexReader)
      {
        throw new IllegalStateException("Message read past expected size (request) for requestId [" + requestId + "], action [" + action + "], readerIndex [" + buffer.readerIndex() + "] vs expected [" + expectedIndexReader + "]; resetting");
      }
      success = true;
    }
    finally {
              if (!success)
              {
                buffer.readerIndex(expectedIndexReader);
              }
            }
  }
  else
  {
    TransportResponseHandler handler = transportServiceAdapter.onResponseReceived(requestId);
    if (handler != null)
    {
      if (TransportStatus.isError(status))
      {
        handlerResponseError(wrappedStream, handler);
      }
      else
      {
        handleResponse(ctx.getChannel(), wrappedStream, handler);
      }
    }
    else
    {
      buffer.readerIndex((markedReaderIndex + size));
    }
    boolean success = false;
    try
    {
      final int nextByte = wrappedStream.read();
      if (nextByte != -1)
      {
        throw new IllegalStateException("Message not fully read (response) for requestId [" + requestId + "], handler [" + handler + "], error [" + TransportStatus.isError(status) + "]; resetting");
      }
      if (buffer.readerIndex() < expectedIndexReader)
      {
        throw new IllegalStateException("Message is fully read (response), yet there are " + expectedIndexReader - buffer.readerIndex() + " remaining bytes; resetting");
      }
      if (buffer.readerIndex() > expectedIndexReader)
      {
        throw new IllegalStateException("Message read past expected size (response) for requestId [" + requestId + "], handler [" + handler + "], error [" + TransportStatus.isError(status) + "]; resetting");
      }
      success = true;
    }
    finally {
              if (!success)
              {
                buffer.readerIndex(expectedIndexReader);
              }
            }
  }
}
finally {
          IOUtils.close(wrappedStream);
        }
Hole 3:
[]: <SKIP>
Hole 4:
[]: <SKIP>
Hole 5:
[]: <SKIP>
Hole 6:
[]: <SKIP>

Edit M:
Hole 1:
[]: StreamInput wrappedStream = null;
Hole 2:
[]: try
{
  if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable())
  {
    Compressor compressor;
    try
    {
      compressor = CompressorFactory.compressor(buffer);
    }
    catch (NotCompressedException ex)
    {
      int maxToRead = Math.min(buffer.readableBytes(), 10);
      int offset = buffer.readerIndex();
      StringBuilder sb = new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(buffer.readableBytes()).append("] readable bytes with message size [").append(size).append("] ").append("] are [");
      for (int i = 0 ; i < maxToRead ; i++)
      {
        sb.append(buffer.getByte((offset + i))).append(",");
      }
      sb.append("]");
      throw new IllegalStateException(sb.toString());
    }
    wrappedStream = compressor.streamInput(streamIn);
  }
  else
  {
    wrappedStream = streamIn;
  }
  wrappedStream = new FilterStreamInput(wrappedStream, namedWriteableRegistry);
  wrappedStream.setVersion(version);
  if (TransportStatus.isRequest(status))
  {
    String action = handleRequest(ctx.getChannel(), wrappedStream, requestId, version);
    boolean success = false;
    try
    {
      final int nextByte = wrappedStream.read();
      if (nextByte != -1)
      {
        throw new IllegalStateException("Message not fully read (request) for requestId [" + requestId + "], action [" + action + "], readerIndex [" + buffer.readerIndex() + "] vs expected [" + expectedIndexReader + "]; resetting");
      }
      if (buffer.readerIndex() < expectedIndexReader)
      {
        throw new IllegalStateException("Message is fully read (request), yet there are " + expectedIndexReader - buffer.readerIndex() + " remaining bytes; resetting");
      }
      if (buffer.readerIndex() > expectedIndexReader)
      {
        throw new IllegalStateException("Message read past expected size (request) for requestId [" + requestId + "], action [" + action + "], readerIndex [" + buffer.readerIndex() + "] vs expected [" + expectedIndexReader + "]; resetting");
      }
      success = true;
    }
    finally {
              if (!success)
              {
                buffer.readerIndex(expectedIndexReader);
              }
            }
  }
  else
  {
    TransportResponseHandler handler = transportServiceAdapter.onResponseReceived(requestId);
    if (handler != null)
    {
      if (TransportStatus.isError(status))
      {
        handlerResponseError(wrappedStream, handler);
      }
      else
      {
        handleResponse(ctx.getChannel(), wrappedStream, handler);
      }
    }
    else
    {
      buffer.readerIndex((markedReaderIndex + size));
    }
    boolean success = false;
    try
    {
      final int nextByte = wrappedStream.read();
      if (nextByte != -1)
      {
        throw new IllegalStateException("Message not fully read (response) for requestId [" + requestId + "], handler [" + handler + "], error [" + TransportStatus.isError(status) + "]; resetting");
      }
      if (buffer.readerIndex() < expectedIndexReader)
      {
        throw new IllegalStateException("Message is fully read (response), yet there are " + expectedIndexReader - buffer.readerIndex() + " remaining bytes; resetting");
      }
      if (buffer.readerIndex() > expectedIndexReader)
      {
        throw new IllegalStateException("Message read past expected size (response) for requestId [" + requestId + "], handler [" + handler + "], error [" + TransportStatus.isError(status) + "]; resetting");
      }
      success = true;
    }
    finally {
              if (!success)
              {
                buffer.readerIndex(expectedIndexReader);
              }
            }
  }
}
finally {
          IOUtils.close(wrappedStream);
        }
Hole 3:
[]: <SKIP>
Hole 4:
[]: <SKIP>
Hole 5:
[]: <SKIP>
Hole 6:
[]: <SKIP>

