Merge Instance for method (Ident "LField",Ident "analyze",[RefType (ClassRefType (ClassType [(Ident "Variables",[])]))])
@Override
 ALink analyze (Variables variables)
{
  if (before == null)
  {
    <?HOLE?>
  }
  <?HOLE?>
  if (sort == Sort.ARRAY)
  {
    <?HOLE?>
  }
  else
    if (sort == Sort.DEF)
    {
      <?HOLE?>
    }
  <?HOLE?>
  field = statik ? struct.staticMembers.get(value) : struct.members.get(value);
  if (field != null)
  {
    <?HOLE?>
    after = field.type;
    return this;
  }
  else
  {
    <?HOLE?>
    if (shortcut)
    {
      <?HOLE?>
    }
    else
    {
      <?HOLE?>
      index.analyze(variables);
      if (Map.class.isAssignableFrom(before.clazz))
      {
        <?HOLE?>
      }
      if (List.class.isAssignableFrom(before.clazz))
      {
        <?HOLE?>
      }
    }
  }
  throw new IllegalArgumentException(error(("Unknown field [" + value + "] for type [" + struct.name + "].")));
}
Edit Base:
Hole 1:
[SCond]: throw new IllegalStateException(error("Illegal tree structure."));
Hole 2:
[]: final Sort sort = before.sort;
Hole 3:
[SCond]: return new LArrayLength(line, location, value).copy(this).analyze(variables);
Hole 4:
[SCond,SCond]: return new LDefField(line, location, value).copy(this).analyze(variables);
Hole 5:
[]: final Struct struct = before.struct;
Hole 6:
[SCond,SCond]: if (store && java.lang.reflect.Modifier.isFinal(field.reflect.getModifiers()))
{
  throw new IllegalArgumentException(error(("Cannot write to read-only field [" + value + "] for type [" + struct.name + "].")));
}
Hole 7:
[SCond]: final boolean shortcut = struct.methods.containsKey(new Definition.MethodKey(("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 0)) || struct.methods.containsKey(new Definition.MethodKey(("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 1));
Hole 8:
[SCond,SCond]: return new LShortcut(line, location, value).copy(this).analyze(variables);
Hole 9:
[SCond,SCond]: final EConstant index = new EConstant(line, location, value);
Hole 10:
[SCond,SCond,SCond]: return new LMapShortcut(line, location, index).copy(this).analyze(variables);
Hole 11:
[SCond,SCond,SCond]: return new LListShortcut(line, location, index).copy(this).analyze(variables);

Edit A:
Hole 1:
[SCond]: throw new IllegalStateException(error("Illegal tree structure."));
Hole 2:
[]: final Sort sort = before.sort;
Hole 3:
[SCond]: return new LArrayLength(line, location, value).copy(this).analyze(variables);
Hole 4:
[SCond,SCond]: return new LDefField(line, location, value).copy(this).analyze(variables);
Hole 5:
[]: final Struct struct = before.struct;
Hole 6:
[SCond,SCond]: if (store && java.lang.reflect.Modifier.isFinal(field.modifiers))
{
  throw new IllegalArgumentException(error(("Cannot write to read-only field [" + value + "] for type [" + struct.name + "].")));
}
Hole 7:
[SCond]: final boolean shortcut = struct.methods.containsKey(new Definition.MethodKey(("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 0)) || struct.methods.containsKey(new Definition.MethodKey(("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 1));
Hole 8:
[SCond,SCond]: return new LShortcut(line, location, value).copy(this).analyze(variables);
Hole 9:
[SCond,SCond]: final EConstant index = new EConstant(line, location, value);
Hole 10:
[SCond,SCond,SCond]: return new LMapShortcut(line, location, index).copy(this).analyze(variables);
Hole 11:
[SCond,SCond,SCond]: return new LListShortcut(line, location, index).copy(this).analyze(variables);

Edit B:
Hole 1:
[SCond]: throw new IllegalArgumentException(error(("Illegal field [" + value + "] access made without target.")));
Hole 2:
[]: Sort sort = before.sort;
Hole 3:
[SCond]: return new LArrayLength(line, offset, location, value).copy(this).analyze(variables);
Hole 4:
[SCond,SCond]: return new LDefField(line, offset, location, value).copy(this).analyze(variables);
Hole 5:
[]: Struct struct = before.struct;
Hole 6:
[SCond]: if (store && java.lang.reflect.Modifier.isFinal(field.reflect.getModifiers()))
{
  throw new IllegalArgumentException(error(("Cannot write to read-only field [" + value + "] for type [" + struct.name + "].")));
}
Hole 7:
[SCond]: boolean shortcut = struct.methods.containsKey(new Definition.MethodKey(("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 0)) || struct.methods.containsKey(new Definition.MethodKey(("is" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 0)) || struct.methods.containsKey(new Definition.MethodKey(("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 1));
Hole 8:
[SCond,SCond]: return new LShortcut(line, offset, location, value).copy(this).analyze(variables);
Hole 9:
[SCond,SCond]: EConstant index = new EConstant(line, offset, location, value);
Hole 10:
[SCond,SCond,SCond]: return new LMapShortcut(line, offset, location, index).copy(this).analyze(variables);
Hole 11:
[SCond,SCond,SCond]: return new LListShortcut(line, offset, location, index).copy(this).analyze(variables);

Edit M:
Hole 1:
[SCond]: throw new IllegalArgumentException(error(("Illegal field [" + value + "] access made without target.")));
Hole 2:
[]: Sort sort = before.sort;
Hole 3:
[SCond]: return new LArrayLength(line, offset, location, value).copy(this).analyze(variables);
Hole 4:
[SCond,SCond]: return new LDefField(line, offset, location, value).copy(this).analyze(variables);
Hole 5:
[]: Struct struct = before.struct;
Hole 6:
[SCond]: if (store && java.lang.reflect.Modifier.isFinal(field.modifiers))
{
  throw new IllegalArgumentException(error(("Cannot write to read-only field [" + value + "] for type [" + struct.name + "].")));
}
Hole 7:
[SCond]: boolean shortcut = struct.methods.containsKey(new Definition.MethodKey(("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 0)) || struct.methods.containsKey(new Definition.MethodKey(("is" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 0)) || struct.methods.containsKey(new Definition.MethodKey(("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1)), 1));
Hole 8:
[SCond,SCond]: return new LShortcut(line, offset, location, value).copy(this).analyze(variables);
Hole 9:
[SCond,SCond]: EConstant index = new EConstant(line, offset, location, value);
Hole 10:
[SCond,SCond,SCond]: return new LMapShortcut(line, offset, location, index).copy(this).analyze(variables);
Hole 11:
[SCond,SCond,SCond]: return new LListShortcut(line, offset, location, index).copy(this).analyze(variables);

