Merge Instance for method (Ident "MultiMatchQueryParser",Ident "parse",[RefType (ClassRefType (ClassType [(Ident "QueryParseContext",[])]))])
@Override
 public Query parse (QueryParseContext parseContext) throws IOException, QueryParsingException
{
  XContentParser parser = parseContext.parser();
  Object value = null;
  <?HOLE?>
  Float tieBreaker = null;
  MultiMatchQueryBuilder.Type type = null;
  MultiMatchQuery multiMatchQuery = new MultiMatchQuery(parseContext);
  String minimumShouldMatch = null;
  Map<String, Float> fieldNameWithBoosts = Maps.newHashMap();
  String queryName = null;
  XContentParser.Token token;
  String currentFieldName = null;
  Boolean useDisMax = null;
  while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
  {
    if (token == XContentParser.Token.FIELD_NAME)
    {
      currentFieldName = parser.currentName();
    }
    else
      if ("fields".equals(currentFieldName))
      {
        if (token == XContentParser.Token.START_ARRAY)
        {
          while (token = parser.nextToken() != XContentParser.Token.END_ARRAY)
          {
            extractFieldAndBoost(parseContext, parser, fieldNameWithBoosts);
          }
        }
        else
          if (token.isValue())
          {
            extractFieldAndBoost(parseContext, parser, fieldNameWithBoosts);
          }
          else
          {
            <?HOLE?>
          }
      }
      else
        if (token.isValue())
        {
          if ("query".equals(currentFieldName))
          {
            value = parser.objectText();
          }
          else
            if ("type".equals(currentFieldName))
            {
              type = MultiMatchQueryBuilder.Type.parse(parser.text(), parseContext.parseFieldMatcher());
            }
            else
              if ("analyzer".equals(currentFieldName))
              {
                String analyzer = parser.text();
                if (parseContext.analysisService().analyzer(analyzer) == null)
                {
                  <?HOLE?>
                }
                multiMatchQuery.setAnalyzer(analyzer);
              }
              else
                if ("boost".equals(currentFieldName))
                {
                  boost = parser.floatValue();
                }
                else
                  if ("slop".equals(currentFieldName) || "phrase_slop".equals(currentFieldName) || "phraseSlop".equals(currentFieldName))
                  {
                    multiMatchQuery.setPhraseSlop(parser.intValue());
                  }
                  else
                    if (parseContext.parseFieldMatcher().match(currentFieldName, Fuzziness.FIELD))
                    {
                      multiMatchQuery.setFuzziness(Fuzziness.parse(parser));
                    }
                    else
                      if ("prefix_length".equals(currentFieldName) || "prefixLength".equals(currentFieldName))
                      {
                        multiMatchQuery.setFuzzyPrefixLength(parser.intValue());
                      }
                      else
                        if ("max_expansions".equals(currentFieldName) || "maxExpansions".equals(currentFieldName))
                        {
                          multiMatchQuery.setMaxExpansions(parser.intValue());
                        }
                        else
                          if ("operator".equals(currentFieldName))
                          {
                            <?HOLE?>
                            <?HOLE?>
                          }
                          else
                            if ("minimum_should_match".equals(currentFieldName) || "minimumShouldMatch".equals(currentFieldName))
                            {
                              minimumShouldMatch = parser.textOrNull();
                            }
                            else
                              <?HOLE?>
        }
  }
  if (value == null)
  {
    throw new QueryParsingException(parseContext, "No text specified for multi_match query");
  }
  if (fieldNameWithBoosts.isEmpty())
  {
    throw new QueryParsingException(parseContext, "No fields specified for multi_match query");
  }
  if (type == null)
  {
    type = MultiMatchQueryBuilder.Type.BEST_FIELDS;
  }
  if (useDisMax != null)
  {
    boolean typeUsesDismax = type.tieBreaker() != 1.0F;
    if (typeUsesDismax != useDisMax)
    {
      if ((useDisMax && tieBreaker) == null)
      {
        multiMatchQuery.setTieBreaker(0.0F);
      }
      else
      {
        multiMatchQuery.setTieBreaker(1.0F);
      }
    }
  }
  Query query = multiMatchQuery.parse(type, fieldNameWithBoosts, value, minimumShouldMatch);
  if (query == null)
  {
    return null;
  }
  query.setBoost(boost);
  if (queryName != null)
  {
    parseContext.addNamedQuery(queryName, query);
  }
  return query;
}
Edit Base:
Hole 1:
[]: float boost = 1.0F;
Hole 2:
[SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + NAME + "] query does not support [" + currentFieldName + "]");
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + NAME + "] analyzer [" + parser.text() + "] not found");
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: String op = parser.text();
Hole 5:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("or".equalsIgnoreCase(op))
{
  multiMatchQuery.setOccur(BooleanClause.Occur.SHOULD);
}
else
  if ("and".equalsIgnoreCase(op))
  {
    multiMatchQuery.setOccur(BooleanClause.Occur.MUST);
  }
  else
  {
    throw new QueryParsingException(parseContext, "text query requires operator to be either 'and' or 'or', not [" + op + "]");
  }
Hole 6:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("rewrite".equals(currentFieldName))
{
  multiMatchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
}
else
  if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
  {
    multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
  }
  else
    if ("use_dis_max".equals(currentFieldName) || "useDisMax".equals(currentFieldName))
    {
      useDisMax = parser.booleanValue();
    }
    else
      if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName))
      {
        multiMatchQuery.setTieBreaker(tieBreaker = parser.floatValue());
      }
      else
        if ("cutoff_frequency".equals(currentFieldName))
        {
          multiMatchQuery.setCommonTermsCutoff(parser.floatValue());
        }
        else
          if ("lenient".equals(currentFieldName))
          {
            multiMatchQuery.setLenient(parser.booleanValue());
          }
          else
            if ("zero_terms_query".equals(currentFieldName))
            {
              String zeroTermsDocs = parser.text();
              if ("none".equalsIgnoreCase(zeroTermsDocs))
              {
                multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
              }
              else
                if ("all".equalsIgnoreCase(zeroTermsDocs))
                {
                  multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
                }
                else
                {
                  throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
                }
            }
            else
              if ("_name".equals(currentFieldName))
              {
                queryName = parser.text();
              }
              else
              {
                throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
              }

Edit A:
Hole 1:
[]: float boost = AbstractQueryBuilder.DEFAULT_BOOST;
Hole 2:
[SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + MultiMatchQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]");
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + MultiMatchQueryBuilder.NAME + "] analyzer [" + parser.text() + "] not found");
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: multiMatchQuery.setOccur(Operator.fromString(parser.text()).toBooleanClauseOccur());
Hole 5:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: <SKIP>
Hole 6:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("rewrite".equals(currentFieldName))
{
  multiMatchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
}
else
  if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
  {
    multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
  }
  else
    if ("use_dis_max".equals(currentFieldName) || "useDisMax".equals(currentFieldName))
    {
      useDisMax = parser.booleanValue();
    }
    else
      if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName))
      {
        multiMatchQuery.setTieBreaker(tieBreaker = parser.floatValue());
      }
      else
        if ("cutoff_frequency".equals(currentFieldName))
        {
          multiMatchQuery.setCommonTermsCutoff(parser.floatValue());
        }
        else
          if ("lenient".equals(currentFieldName))
          {
            multiMatchQuery.setLenient(parser.booleanValue());
          }
          else
            if ("zero_terms_query".equals(currentFieldName))
            {
              String zeroTermsDocs = parser.text();
              if ("none".equalsIgnoreCase(zeroTermsDocs))
              {
                multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
              }
              else
                if ("all".equalsIgnoreCase(zeroTermsDocs))
                {
                  multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
                }
                else
                {
                  throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
                }
            }
            else
              if ("_name".equals(currentFieldName))
              {
                queryName = parser.text();
              }
              else
              {
                throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
              }

Edit B:
Hole 1:
[]: float boost = 1.0F;
Hole 2:
[SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + NAME + "] query does not support [" + currentFieldName + "]");
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + NAME + "] analyzer [" + parser.text() + "] not found");
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: String op = parser.text();
Hole 5:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("or".equalsIgnoreCase(op))
{
  multiMatchQuery.setOccur(BooleanClause.Occur.SHOULD);
}
else
  if ("and".equalsIgnoreCase(op))
  {
    multiMatchQuery.setOccur(BooleanClause.Occur.MUST);
  }
  else
  {
    throw new QueryParsingException(parseContext, "text query requires operator to be either 'and' or 'or', not [" + op + "]");
  }
Hole 6:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
{
  multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parseContext.parseFieldMatcher(), parser.textOrNull(), null));
}
else
  if ("use_dis_max".equals(currentFieldName) || "useDisMax".equals(currentFieldName))
  {
    useDisMax = parser.booleanValue();
  }
  else
    if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName))
    {
      multiMatchQuery.setTieBreaker(tieBreaker = parser.floatValue());
    }
    else
      if ("cutoff_frequency".equals(currentFieldName))
      {
        multiMatchQuery.setCommonTermsCutoff(parser.floatValue());
      }
      else
        if ("lenient".equals(currentFieldName))
        {
          multiMatchQuery.setLenient(parser.booleanValue());
        }
        else
          if ("zero_terms_query".equals(currentFieldName))
          {
            String zeroTermsDocs = parser.text();
            if ("none".equalsIgnoreCase(zeroTermsDocs))
            {
              multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
            }
            else
              if ("all".equalsIgnoreCase(zeroTermsDocs))
              {
                multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
              }
              else
              {
                throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
              }
          }
          else
            if ("_name".equals(currentFieldName))
            {
              queryName = parser.text();
            }
            else
            {
              throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
            }

Edit M:
Hole 1:
[]: float boost = AbstractQueryBuilder.DEFAULT_BOOST;
Hole 2:
[SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + MultiMatchQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]");
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: throw new QueryParsingException(parseContext, "[" + MultiMatchQueryBuilder.NAME + "] analyzer [" + parser.text() + "] not found");
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: multiMatchQuery.setOccur(Operator.fromString(parser.text()).toBooleanClauseOccur());
Hole 5:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: <SKIP>
Hole 6:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
{
  multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parseContext.parseFieldMatcher(), parser.textOrNull(), null));
}
else
  if ("use_dis_max".equals(currentFieldName) || "useDisMax".equals(currentFieldName))
  {
    useDisMax = parser.booleanValue();
  }
  else
    if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName))
    {
      multiMatchQuery.setTieBreaker(tieBreaker = parser.floatValue());
    }
    else
      if ("cutoff_frequency".equals(currentFieldName))
      {
        multiMatchQuery.setCommonTermsCutoff(parser.floatValue());
      }
      else
        if ("lenient".equals(currentFieldName))
        {
          multiMatchQuery.setLenient(parser.booleanValue());
        }
        else
          if ("zero_terms_query".equals(currentFieldName))
          {
            String zeroTermsDocs = parser.text();
            if ("none".equalsIgnoreCase(zeroTermsDocs))
            {
              multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
            }
            else
              if ("all".equalsIgnoreCase(zeroTermsDocs))
              {
                multiMatchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
              }
              else
              {
                throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
              }
          }
          else
            if ("_name".equals(currentFieldName))
            {
              queryName = parser.text();
            }
            else
            {
              throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
            }

