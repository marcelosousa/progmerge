Merge Instance for method (Ident "RestUpdateByQueryAction",Ident "handleRequest",[RefType (ClassRefType (ClassType [(Ident "RestRequest",[])])),RefType (ClassRefType (ClassType [(Ident "RestChannel",[])])),RefType (ClassRefType (ClassType [(Ident "Client",[])]))])
@Override
 protected void handleRequest (RestRequest request, RestChannel channel, Client client) throws Exception
{
  UpdateByQueryRequest internalRequest = new UpdateByQueryRequest(new SearchRequest());
  int scrollSize = internalRequest.getSearchRequest().source().size();
  internalRequest.getSearchRequest().source().size(SIZE_ALL_MATCHES);
  BytesReference bodyContent = null;
  if (RestActions.hasBodyContent(request))
  {
    bodyContent = RestActions.getRestContent(request);
    Tuple<XContentType, Map<String, Object>> body = XContentHelper.convertToMap(bodyContent, false);
    boolean modified = false;
    String conflicts = (String) body.v2().remove("conflicts");
    if (conflicts != null)
    {
      internalRequest.setConflicts(conflicts);
      modified = true;
    }
    @SuppressWarnings("unchecked")
    Map<String, Object> script = (Map<String, Object>) body.v2().remove("script");
    if (script != null)
    {
      internalRequest.setScript(Script.parse(script, false, parseFieldMatcher));
      modified = true;
    }
    if (modified)
    {
      XContentBuilder builder = XContentFactory.contentBuilder(body.v1());
      builder.map(body.v2());
      bodyContent = builder.bytes();
    }
  }
  <?HOLE?>
  String conflicts = request.param("conflicts");
  if (conflicts != null)
  {
    internalRequest.setConflicts(conflicts);
  }
  parseCommon(internalRequest, request);
  internalRequest.setSize(internalRequest.getSearchRequest().source().size());
  internalRequest.setPipeline(request.param("pipeline"));
  internalRequest.getSearchRequest().source().size(request.paramAsInt("scroll_size", scrollSize));
  <?HOLE?>
  execute(request, internalRequest, channel);
}
Edit Base:
Hole 1:
[]: RestSearchAction.parseSearchRequest(internalRequest.getSearchRequest(), indicesQueriesRegistry, request, parseFieldMatcher, aggParsers, bodyContent);
Hole 2:
[]: <SKIP>

Edit A:
Hole 1:
[]: RestSearchAction.parseSearchRequest(internalRequest.getSearchRequest(), indicesQueriesRegistry, request, parseFieldMatcher, aggParsers, bodyContent);
Hole 2:
[]: if (request.hasParam("search_timeout"))
{
  internalRequest.getSearchRequest().source().timeout(request.paramAsTime("search_timeout", null));
}

Edit B:
Hole 1:
[]: RestSearchAction.parseSearchRequest(internalRequest.getSearchRequest(), indicesQueriesRegistry, request, parseFieldMatcher, aggParsers, suggesters, bodyContent);
Hole 2:
[]: <SKIP>

Edit M:
Hole 1:
[]: RestSearchAction.parseSearchRequest(internalRequest.getSearchRequest(), indicesQueriesRegistry, request, parseFieldMatcher, aggParsers, suggesters, bodyContent);
Hole 2:
[]: if (request.hasParam("search_timeout"))
{
  internalRequest.getSearchRequest().source().timeout(request.paramAsTime("search_timeout", null));
}

