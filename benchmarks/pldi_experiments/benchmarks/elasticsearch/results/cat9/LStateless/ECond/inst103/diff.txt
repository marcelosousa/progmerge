Merge Instance for method (Ident "RecoveryFromGatewayIT",Ident "testReusePeerRecovery",[])
@TestLogging("gateway:TRACE,indices.recovery:TRACE,index.engine:TRACE")
 public void testReusePeerRecovery () throws Exception
{
  final Settings settings = settingsBuilder().put("action.admin.cluster.node.shutdown.delay", "10ms").put(MockFSIndexStore.CHECK_INDEX_ON_CLOSE, false).put("gateway.recover_after_nodes", 4).put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES, 4).put(MockFSDirectoryService.CRASH_INDEX, false).build();
  internalCluster().startNodesAsync(4, settings).get();
  assertAcked(prepareCreate("test").setSettings(Settings.builder().put(indexSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)));
  ensureGreen();
  logger.info("--> indexing docs");
  for (int i = 0 ; i < 1000 ; i++)
  {
    client().prepareIndex("test", "type").setSource("field", "value").execute().actionGet();
    if (i % 200 == 0)
    {
      client().admin().indices().prepareFlush().execute().actionGet();
    }
  }
  if (randomBoolean())
  {
    client().admin().indices().prepareFlush().execute().actionGet();
  }
  logger.info("Running Cluster Health");
  ensureGreen();
  client().admin().indices().prepareForceMerge("test").setMaxNumSegments(100).get();
  client().admin().indices().prepareFlush().setWaitIfOngoing(true).setForce(true).get();
  boolean useSyncIds = randomBoolean();
  if (useSyncIds == false)
  {
    logger.info("--> disabling allocation while the cluster is shut down");
    <?HOLE?>
    logger.info("--> full cluster restart");
    internalCluster().fullRestart();
    logger.info("--> waiting for cluster to return to green after first shutdown");
    ensureGreen();
  }
  else
  {
    logger.info("--> trying to sync flush");
    <?HOLE?>
    assertSyncIdsNotNull();
  }
  logger.info("--> disabling allocation while the cluster is shut down", (useSyncIds ? "" : " a second time"));
  <?HOLE?>
  logger.info("--> full cluster restart");
  internalCluster().fullRestart();
  logger.info("--> waiting for cluster to return to green after {}shutdown", (useSyncIds ? "" : "second "));
  ensureGreen();
  if (useSyncIds)
  {
    assertSyncIdsNotNull();
  }
  RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries("test").get();
  for (RecoveryState recoveryState : recoveryResponse.shardRecoveryStates().get("test")) {
                                                                                           long recovered = 0;
                                                                                           for (RecoveryState.File file : recoveryState.getIndex().fileDetails()) {
                                                                                                                                                                    if (file.name().startsWith("segments"))
                                                                                                                                                                    {
                                                                                                                                                                      recovered += file.length();
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                           if (!recoveryState.getPrimary() && useSyncIds == false)
                                                                                           {
                                                                                             logger.info("--> replica shard {} recovered from {} to {}, recovered {}, reuse {}", recoveryState.getShardId().getId(), recoveryState.getSourceNode().name(), recoveryState.getTargetNode().name(), recoveryState.getIndex().recoveredBytes(), recoveryState.getIndex().reusedBytes());
                                                                                             assertThat("no bytes should be recovered", recoveryState.getIndex().recoveredBytes(), equalTo(recovered));
                                                                                             assertThat("data should have been reused", recoveryState.getIndex().reusedBytes(), greaterThan(0L));
                                                                                             assertThat("all bytes should be reused except of the segments file", recoveryState.getIndex().reusedBytes(), equalTo((recoveryState.getIndex().totalBytes() - recovered)));
                                                                                             assertThat("no files should be recovered except of the segments file", recoveryState.getIndex().recoveredFileCount(), equalTo(1));
                                                                                             assertThat("all files should be reused except of the segments file", recoveryState.getIndex().reusedFileCount(), equalTo((recoveryState.getIndex().totalFileCount() - 1)));
                                                                                             assertThat("> 0 files should be reused", recoveryState.getIndex().reusedFileCount(), greaterThan(0));
                                                                                           }
                                                                                           else
                                                                                           {
                                                                                             if (useSyncIds && !recoveryState.getPrimary())
                                                                                             {
                                                                                               logger.info("--> replica shard {} recovered from {} to {} using sync id, recovered {}, reuse {}", recoveryState.getShardId().getId(), recoveryState.getSourceNode().name(), recoveryState.getTargetNode().name(), recoveryState.getIndex().recoveredBytes(), recoveryState.getIndex().reusedBytes());
                                                                                             }
                                                                                             assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));
                                                                                             assertThat(recoveryState.getIndex().reusedBytes(), equalTo(recoveryState.getIndex().totalBytes()));
                                                                                             assertThat(recoveryState.getIndex().recoveredFileCount(), equalTo(0));
                                                                                             assertThat(recoveryState.getIndex().reusedFileCount(), equalTo(recoveryState.getIndex().totalFileCount()));
                                                                                           }
                                                                                         }
}
Edit Base:
Hole 1:
[SCond]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE, EnableAllocationDecider.Allocation.NONE)).get();
Hole 2:
[SCond]: assertEquals(SyncedFlushUtil.attemptSyncedFlush(internalCluster(), "test").failedShards(), 0);
Hole 3:
[]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE, EnableAllocationDecider.Allocation.NONE)).get();

Edit A:
Hole 1:
[SCond]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), EnableAllocationDecider.Allocation.NONE)).get();
Hole 2:
[SCond]: assertEquals(SyncedFlushUtil.attemptSyncedFlush(internalCluster(), "test").failedShards(), 0);
Hole 3:
[]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), EnableAllocationDecider.Allocation.NONE)).get();

Edit B:
Hole 1:
[SCond]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE, EnableAllocationDecider.Allocation.NONE)).get();
Hole 2:
[SCond]: assertEquals(client().admin().indices().prepareSyncedFlush("test").get().failedShards(), 0);
Hole 3:
[]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE, EnableAllocationDecider.Allocation.NONE)).get();

Edit M:
Hole 1:
[SCond]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), EnableAllocationDecider.Allocation.NONE)).get();
Hole 2:
[SCond]: assertEquals(client().admin().indices().prepareSyncedFlush("test").get().failedShards(), 0);
Hole 3:
[]: client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), EnableAllocationDecider.Allocation.NONE)).get();

