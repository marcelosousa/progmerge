Merge Instance for method (Ident "FunctionCodegen",Ident "generatedMethod",[RefType (ClassRefType (ClassType [(Ident "JetExpression",[])])),RefType (ClassRefType (ClassType [(Ident "JvmMethodSignature",[])])),PrimType BooleanT,RefType (ClassRefType (ClassType [(Ident "String",[])])),RefType (ClassRefType (ClassType [(Ident "CodegenContext",[]),(Ident "MethodContext",[])])),RefType (ClassRefType (ClassType [(Ident "FunctionDescriptor",[])])),RefType (ClassRefType (ClassType [(Ident "JetDeclarationWithBody",[])]))])
private void generatedMethod (JetExpression bodyExpressions, JvmMethodSignature jvmSignature, boolean needJetAnnotations, @Nullable
                                                                                                                          String propertyTypeSignature, CodegenContext.MethodContext context, FunctionDescriptor functionDescriptor, JetDeclarationWithBody fun)
{
  if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE)
  {
    throw new IllegalStateException("must not generate code for fake overrides");
  }
  List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();
  <?HOLE?>
  if ((!functionDescriptor.getValueParameters().isEmpty() && functionDescriptor.getValueParameters().get((functionDescriptor.getValueParameters().size() - 1)).getVarargElementType()) != null)
  {
    flags |= ACC_VARARGS;
  }
  Modality modality = functionDescriptor.getModality();
  if (modality == Modality.FINAL)
  {
    DeclarationDescriptor containingDeclaration = functionDescriptor.getContainingDeclaration();
    if ((!(containingDeclaration instanceof ClassDescriptor) || ((ClassDescriptor) containingDeclaration).getKind()) != ClassKind.TRAIT)
    {
      flags |= ACC_FINAL;
    }
  }
  OwnerKind kind = context.getContextKind();
  if (kind == OwnerKind.TRAIT_IMPL)
  {
    needJetAnnotations = false;
  }
  ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();
  ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();
  if ((kind != OwnerKind.TRAIT_IMPL || bodyExpressions) != null)
  {
    boolean isStatic = (kind == OwnerKind.NAMESPACE || kind) instanceof OwnerKind.StaticDelegateKind;
    if ((isStatic || kind) == OwnerKind.TRAIT_IMPL)
    {
      flags |= ACC_STATIC;
    }
    <?HOLE?>
    if (isAbstract)
      flags |= ACC_ABSTRACT;
    final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);
    AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);
    if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES)
    {
      int start = 0;
      if (needJetAnnotations)
      {
        if (functionDescriptor instanceof PropertyAccessorDescriptor)
        {
          PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter(), ((PropertyAccessorDescriptor) functionDescriptor).getCorrespondingProperty(), functionDescriptor.getVisibility());
        }
        else
          if (functionDescriptor instanceof SimpleFunctionDescriptor)
          {
            if (propertyTypeSignature != null)
            {
              throw new IllegalStateException();
            }
            JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);
            <?HOLE?>
            <?HOLE?>
            aw.writeFlags(kotlinFlags);
            aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());
            aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
            aw.writeReturnType(jvmSignature.getKotlinReturnType());
            aw.visitEnd();
          }
          else
          {
            throw new IllegalStateException();
          }
        if (receiverParameter.exists())
        {
          JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, start++);
          av.writeName("this$receiver");
          av.writeNullable(receiverParameter.getType().isNullable());
          av.writeReceiver();
          if ((jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0)) != null)
          {
            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());
          }
          av.visitEnd();
        }
        for (int i = 0 ; i != paramDescrs.size() ; ++i)
        {
          ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);
          AnnotationCodegen.forParameter(i, mv, state.getInjector().getJetTypeMapper()).genAnnotations(parameterDescriptor);
          JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, (i + start));
          av.writeName(parameterDescriptor.getName().getName());
          av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());
          av.writeNullable(parameterDescriptor.getType().isNullable());
          if ((jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i)) != null)
          {
            av.writeType(jvmSignature.getKotlinParameterTypes().get((i + start)).getKotlinSignature());
          }
          av.visitEnd();
        }
      }
    }
    if ((!isAbstract && state.getClassBuilderMode()) == ClassBuilderMode.STUBS)
    {
      StubCodegen.generateStubCode(mv);
    }
    if ((!isAbstract && state.getClassBuilderMode()) == ClassBuilderMode.FULL)
    {
      mv.visitCode();
      Label methodBegin = new Label();
      mv.visitLabel(methodBegin);
      FrameMap frameMap = context.prepareFrame(state.getInjector().getJetTypeMapper());
      ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);
      Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();
      int add = 0;
      if (kind == OwnerKind.TRAIT_IMPL)
      {
        add++;
      }
      if (receiverParameter.exists())
      {
        add++;
      }
      for (int i = 0 ; i < paramDescrs.size() ; i++)
      {
        ValueParameterDescriptor parameter = paramDescrs.get(i);
        frameMap.enter(parameter, argTypes[(i + add)]);
      }
      if ((!isStatic && kind instanceof OwnerKind.DelegateKind) != functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)
      {
        throw new IllegalStateException("mismatching kind in " + functionDescriptor);
      }
      Map<Name, Label> mapLabelsToDivideLocalVarVisibilityForSharedVar = new HashMap<Name, Label>();
      if (kind instanceof OwnerKind.StaticDelegateKind)
      {
        OwnerKind.StaticDelegateKind dk = (OwnerKind.StaticDelegateKind) kind;
        InstructionAdapter iv = new InstructionAdapter(mv);
        for (int i = 0, k = 0 ; i < argTypes.length ; i++)
        {
          Type argType = argTypes[i];
          iv.load(k, argType);
          k += argType.getSize();
        }
        iv.invokestatic(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());
        iv.areturn(jvmSignature.getAsmMethod().getReturnType());
      }
      else
        if (kind instanceof OwnerKind.DelegateKind)
        {
          OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;
          InstructionAdapter iv = new InstructionAdapter(mv);
          <?HOLE?>
          <?HOLE?>
          for (int i = 0 ; i < argTypes.length ; i++)
          {
            Type argType = argTypes[i];
            iv.load((i + 1), argType);
          }
          iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());
          iv.areturn(jvmSignature.getAsmMethod().getReturnType());
        }
        else
        {
          for (ValueParameterDescriptor parameter : paramDescrs) {
                                                                   Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);
                                                                   if (sharedVarType != null)
                                                                   {
                                                                     Type localVarType = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);
                                                                     int index = frameMap.getIndex(parameter);
                                                                     mv.visitTypeInsn(NEW, sharedVarType.getInternalName());
                                                                     mv.visitInsn(DUP);
                                                                     mv.visitInsn(DUP);
                                                                     mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), "<init>", "()V");
                                                                     mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);
                                                                     mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), "ref", StackValue.refType(localVarType).getDescriptor());
                                                                     Label labelToDivideLocalVarForSharedVarVisibility = new Label();
                                                                     mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);
                                                                     mapLabelsToDivideLocalVarVisibilityForSharedVar.put(parameter.getName(), labelToDivideLocalVarForSharedVarVisibility);
                                                                     mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);
                                                                   }
                                                                 }
          codegen.returnExpression(bodyExpressions);
        }
      Label methodEnd = new Label();
      mv.visitLabel(methodEnd);
      Collection<String> localVariableNames = new HashSet<String>();
      localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());
      for (ValueParameterDescriptor parameterDescriptor : paramDescrs) {
                                                                         localVariableNames.add(parameterDescriptor.getName().getName());
                                                                       }
      int k = 0;
      if (expectedThisObject.exists())
      {
        Type type = state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(), MapTypeMode.VALUE);
        mv.visitLocalVariable("this", type.getDescriptor(), null, methodBegin, methodEnd, k++);
      }
      else
        if (fun instanceof JetFunctionLiteralExpression || isLocalFun(state.getBindingContext(), functionDescriptor))
        {
          Type type = state.getInjector().getJetTypeMapper().mapType(context.getThisDescriptor().getDefaultType(), MapTypeMode.VALUE);
          mv.visitLocalVariable("this", type.getDescriptor(), null, methodBegin, methodEnd, k++);
        }
      if (receiverParameter.exists())
      {
        Type type = state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(), MapTypeMode.VALUE);
        mv.visitLocalVariable("this$receiver", type.getDescriptor(), null, methodBegin, methodEnd, k);
        k += type.getSize();
      }
      for (ValueParameterDescriptor parameter : paramDescrs) {
                                                               Type type = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);
                                                               Label divideLabel = mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());
                                                               String parameterName = parameter.getName().getName();
                                                               if (divideLabel != null)
                                                               {
                                                                 Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);
                                                                 mv.visitLocalVariable(parameterName, type.getDescriptor(), null, methodBegin, divideLabel, k);
                                                                 <?HOLE?>
                                                                 localVariableNames.add(nameForSharedVar);
                                                                 mv.visitLocalVariable(nameForSharedVar, sharedVarType.getDescriptor(), null, divideLabel, methodEnd, k);
                                                                 k += Math.max(type.getSize(), sharedVarType.getSize());
                                                               }
                                                               else
                                                               {
                                                                 mv.visitLocalVariable(parameter.getName().getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);
                                                                 k += type.getSize();
                                                               }
                                                             }
      endVisit(mv, null, fun);
      generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);
    }
  }
  generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);
}
Edit Base:
Hole 1:
[]: int flags = JetTypeMapper.getAccessModifiers(functionDescriptor, 0);
Hole 2:
[SCond]: boolean isAbstract = ((modality == Modality.ABSTRACT || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())) && !isStatic && kind) != OwnerKind.TRAIT_IMPL;
Hole 3:
[SCond,SCond,SCond,SCond,SCond]: BitSet kotlinFlags = CodegenUtil.getFlagsForVisibility(functionDescriptor.getVisibility());
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond]: if ((CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality) != Modality.ABSTRACT)
{
  kotlinFlags.set((modality == Modality.FINAL ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT : JvmStdlibNames.FLAG_FORCE_OPEN_BIT));
}
Hole 5:
[SCond,SCond,SCond,SCond]: iv.load(0, JetTypeMapper.OBJECT_TYPE);
Hole 6:
[SCond,SCond,SCond,SCond]: dk.getDelegate().put(JetTypeMapper.OBJECT_TYPE, iv);
Hole 7:
[SCond,SLoop,SCond,SCond]: String nameForSharedVar = CodegenUtil.generateTmpVariableName(localVariableNames);

Edit A:
Hole 1:
[]: int flags = getVisibilityAccessFlag(functionDescriptor);
Hole 2:
[SCond]: boolean isAbstract = ((modality == Modality.ABSTRACT || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())) && !isStatic && kind) != OwnerKind.TRAIT_IMPL;
Hole 3:
[SCond,SCond,SCond,SCond,SCond]: BitSet kotlinFlags = CodegenUtil.getFlagsForVisibility(functionDescriptor.getVisibility());
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond]: if ((CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality) != Modality.ABSTRACT)
{
  kotlinFlags.set((modality == Modality.FINAL ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT : JvmStdlibNames.FLAG_FORCE_OPEN_BIT));
}
Hole 5:
[SCond,SCond,SCond,SCond]: iv.load(0, JetTypeMapper.OBJECT_TYPE);
Hole 6:
[SCond,SCond,SCond,SCond]: dk.getDelegate().put(JetTypeMapper.OBJECT_TYPE, iv);
Hole 7:
[SCond,SLoop,SCond,SCond]: String nameForSharedVar = CodegenUtil.generateTmpVariableName(localVariableNames);

Edit B:
Hole 1:
[]: int flags = getAccessModifiers(functionDescriptor, 0);
Hole 2:
[SCond]: boolean isAbstract = ((modality == Modality.ABSTRACT || isInterface(functionDescriptor.getContainingDeclaration())) && !isStatic && kind) != OwnerKind.TRAIT_IMPL;
Hole 3:
[SCond,SCond,SCond,SCond,SCond]: BitSet kotlinFlags = getFlagsForVisibility(functionDescriptor.getVisibility());
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond]: if ((isInterface(functionDescriptor.getContainingDeclaration()) && modality) != Modality.ABSTRACT)
{
  kotlinFlags.set((modality == Modality.FINAL ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT : JvmStdlibNames.FLAG_FORCE_OPEN_BIT));
}
Hole 5:
[SCond,SCond,SCond,SCond]: iv.load(0, OBJECT_TYPE);
Hole 6:
[SCond,SCond,SCond,SCond]: dk.getDelegate().put(OBJECT_TYPE, iv);
Hole 7:
[SCond,SLoop,SCond,SCond]: String nameForSharedVar = generateTmpVariableName(localVariableNames);

Edit M:
Hole 1:
[]: int flags = getVisibilityAccessFlag(functionDescriptor);
Hole 2:
[SCond]: boolean isAbstract = ((modality == Modality.ABSTRACT || isInterface(functionDescriptor.getContainingDeclaration())) && !isStatic && kind) != OwnerKind.TRAIT_IMPL;
Hole 3:
[SCond,SCond,SCond,SCond,SCond]: BitSet kotlinFlags = getFlagsForVisibility(functionDescriptor.getVisibility());
Hole 4:
[SCond,SCond,SCond,SCond,SCond]: if ((isInterface(functionDescriptor.getContainingDeclaration()) && modality) != Modality.ABSTRACT)
{
  kotlinFlags.set((modality == Modality.FINAL ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT : JvmStdlibNames.FLAG_FORCE_OPEN_BIT));
}
Hole 5:
[SCond,SCond,SCond,SCond]: iv.load(0, OBJECT_TYPE);
Hole 6:
[SCond,SCond,SCond,SCond]: dk.getDelegate().put(OBJECT_TYPE, iv);
Hole 7:
[SCond,SLoop,SCond,SCond]: String nameForSharedVar = generateTmpVariableName(localVariableNames);

