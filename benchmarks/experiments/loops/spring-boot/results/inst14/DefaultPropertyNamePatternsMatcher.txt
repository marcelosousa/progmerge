Parsing files...
Merge Instance for method (Ident "DefaultPropertyNamePatternsMatcher",Ident "matches",[RefType (ClassRefType (ClassType [(Ident "String",[])]))])
@Override
 public boolean matches (String propertyName)
{
  <?HOLE?>
  boolean[] match = new boolean[this.names.length];
  boolean noneMatched = true;
  for (int i = 0 ; i < this.names.length ; i++)
  {
    <?HOLE?>
  }
  if (noneMatched)
  {
    return false;
  }
  <?HOLE?>
  for (int i = 0 ; i < match.length ; i++)
  {
    if (match[i])
    {
      return true;
    }
  }
  return false;
}
Edit Base:
Hole 1:
[]: char[] propertNameChars = propertyName.toCharArray();
Hole 2:
[SCond,SLoop]: if (this.names[i].length() <= propertNameChars.length)
{
  match[i] = true;
  noneMatched = false;
}
Hole 3:
[SLoop]: for (int charIndex = 0 ; charIndex < propertNameChars.length ; charIndex++)
{
  noneMatched = true;
  for (int nameIndex = 0 ; nameIndex < this.names.length ; nameIndex++)
  {
    if (match[nameIndex])
    {
      if (charIndex < this.names[nameIndex].length())
      {
        if (this.names[nameIndex].charAt(charIndex) == propertNameChars[charIndex])
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
      else
      {
        char charAfter = propertNameChars[this.names[nameIndex].length()];
        if ((charAfter == '.' || charAfter) == '_')
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
    }
  }
  if (noneMatched)
  {
    return false;
  }
}

Edit A:
Hole 1:
[]: char[] propertyNameChars = propertyName.toCharArray();
Hole 2:
[SCond,SLoop]: if (this.names[i].length() <= propertyNameChars.length)
{
  match[i] = true;
  noneMatched = false;
}
Hole 3:
[SLoop]: for (int charIndex = 0 ; charIndex < propertyNameChars.length ; charIndex++)
{
  for (int nameIndex = 0 ; nameIndex < this.names.length ; nameIndex++)
  {
    if (match[nameIndex])
    {
      match[nameIndex] = false;
      if (charIndex < this.names[nameIndex].length())
      {
        if (isCharMatch(this.names[nameIndex].charAt(charIndex), propertyNameChars[charIndex]))
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
      else
      {
        char charAfter = propertyNameChars[this.names[nameIndex].length()];
        if (isDelimiter(charAfter))
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
    }
  }
  if (noneMatched)
  {
    return false;
  }
}

Edit B:
Hole 1:
[]: char[] propertNameChars = propertyName.toCharArray();
Hole 2:
[SLoop]: if (this.names[i].length() <= propertNameChars.length)
{
  match[i] = true;
  noneMatched = false;
}
Hole 3:
[]: for (int charIndex = 0 ; charIndex < propertNameChars.length ; charIndex++)
{
  noneMatched = true;
  for (int nameIndex = 0 ; nameIndex < this.names.length ; nameIndex++)
  {
    if (match[nameIndex])
    {
      if (charIndex < this.names[nameIndex].length())
      {
        if (this.names[nameIndex].charAt(charIndex) == propertNameChars[charIndex])
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
      else
      {
        char charAfter = propertNameChars[this.names[nameIndex].length()];
        if ((charAfter == '.' || charAfter) == '_')
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
    }
  }
  if (noneMatched)
  {
    return false;
  }
}

Edit M:
Hole 1:
[]: char[] propertyNameChars = propertyName.toCharArray();
Hole 2:
[SLoop]: if (this.names[i].length() <= propertyNameChars.length)
{
  match[i] = true;
  noneMatched = false;
}
Hole 3:
[]: for (int charIndex = 0 ; charIndex < propertyNameChars.length ; charIndex++)
{
  for (int nameIndex = 0 ; nameIndex < this.names.length ; nameIndex++)
  {
    if (match[nameIndex])
    {
      match[nameIndex] = false;
      if (charIndex < this.names[nameIndex].length())
      {
        if (isCharMatch(this.names[nameIndex].charAt(charIndex), propertyNameChars[charIndex]))
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
      else
      {
        char charAfter = propertyNameChars[this.names[nameIndex].length()];
        if (isDelimiter(charAfter))
        {
          match[nameIndex] = true;
          noneMatched = false;
        }
      }
    }
  }
  if (noneMatched)
  {
    return false;
  }
}


