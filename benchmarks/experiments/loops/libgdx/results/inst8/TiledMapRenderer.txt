Parsing files...
Merge Instance for method (Ident "TiledMapRenderer",Ident "renderLayer",[PrimType FloatT,PrimType FloatT,PrimType FloatT,PrimType FloatT,RefType (ClassRefType (ClassType [(Ident "MapLayer",[])]))])
protected void renderLayer (float camLeft, float camTop, float camRight, float camBottom, MapLayer layer)
{
  if (layer.getVisible())
  {
    <?HOLE?>
    if (layer instanceof TiledMapTileLayer)
    {
      final TiledMapTileLayer tileLayer = (TiledMapTileLayer) layer;
      final int layerWidth = tileLayer.getWidth();
      final int layerHeight = tileLayer.getHeight();
      final float layerTileWidth = tileLayer.getTileWidth() * unitScale;
      final float layerTileHeight = tileLayer.getTileHeight() * unitScale;
      <?HOLE?>
      <?HOLE?>
      <?HOLE?>
      <?HOLE?>
      <?HOLE?>
    }
  }
}
Edit Base:
Hole 1:
[SCond]: spriteBatch.setColor(1, 1, 1, layer.getOpacity());
Hole 2:
[SCond,SCond]: final int x1 = Math.max(0, ((int) (camLeft / layerTileWidth)));
Hole 3:
[SCond,SCond]: final int x2 = Math.min(layerWidth, ((int) ((camRight + layerTileWidth) / layerTileWidth)));
Hole 4:
[SCond,SCond]: final int y1 = Math.max(0, ((int) (camBottom / layerTileHeight)));
Hole 5:
[SCond,SCond]: final int y2 = Math.min(layerHeight, ((int) ((camTop + layerTileHeight) / layerTileHeight)));
Hole 6:
[SLoop,SCond,SCond]: for (int x = x1 ; x < x2 ; x++)
{
  for (int y = y1 ; y < y2 ; y++)
  {
    final TiledMapTileLayer.Cell cell = tileLayer.getCell(x, y);
    final TiledMapTile tile = cell.getTile();
    if (tile != null)
    {
      final boolean flipX = cell.getFlipHorizontally();
      final boolean flipY = cell.getFlipVertically();
      final float rotate = cell.getRotation();
      TextureRegion region = tile.getTextureRegion();
      float drawX = x * layerTileWidth;
      float drawY = y * layerTileHeight;
      float width = region.getRegionWidth() * unitScale;
      float height = region.getRegionHeight() * unitScale;
      float originX = width * 0.5F;
      float originY = height * 0.5F;
      float scaleX = 1;
      float scaleY = 1;
      float rotation = 0;
      int sourceX = region.getRegionX();
      int sourceY = region.getRegionY();
      int sourceWidth = region.getRegionWidth();
      int sourceHeight = region.getRegionHeight();
      if (flipX)
      {
        sourceX += sourceWidth;
        sourceWidth = -sourceWidth;
      }
      if (flipY)
      {
        sourceY += sourceHeight;
        sourceHeight = -sourceHeight;
      }
      if (rotation == 0)
      {
        spriteBatch.draw(region.getTexture(), drawX, drawY, width, height, sourceX, sourceY, sourceWidth, sourceHeight, false, false);
      }
      else
      {
        spriteBatch.draw(region.getTexture(), drawX, drawY, originX, originY, width, height, scaleX, scaleY, rotate, sourceX, sourceY, sourceWidth, sourceHeight, false, false);
      }
    }
  }
}

Edit A:
Hole 1:
[SCond]: float color = Color.toFloatBits(1, 1, 1, layer.getOpacity());
Hole 2:
[SCond,SCond]: final int col1 = Math.max(0, ((int) (camLeft / layerTileWidth)));
Hole 3:
[SCond,SCond]: final int col2 = Math.min(layerWidth, ((int) ((camRight + layerTileWidth) / layerTileWidth)));
Hole 4:
[SCond,SCond]: final int row1 = Math.max(0, ((int) (camBottom / layerTileHeight)));
Hole 5:
[SCond,SCond]: final int row2 = Math.min(layerHeight, ((int) ((camTop + layerTileHeight) / layerTileHeight)));
Hole 6:
[SLoop,SCond,SCond]: for (int row = row1 ; row < row2 ; row++)
{
  for (int col = col1 ; col < col2 ; col++)
  {
    final TiledMapTileLayer.Cell cell = tileLayer.getCell(col, row);
    final TiledMapTile tile = cell.getTile();
    if (tile != null)
    {
      final boolean flipX = cell.getFlipHorizontally();
      final boolean flipY = cell.getFlipVertically();
      final int rotations = cell.getRotation();
      TextureRegion region = tile.getTextureRegion();
      float x1 = col * layerTileWidth;
      float y1 = row * layerTileHeight;
      float x2 = (x1 + region.getRegionWidth()) * unitScale;
      float y2 = (y1 + region.getRegionHeight()) * unitScale;
      float u1 = region.getU();
      float v1 = region.getV2();
      float u2 = region.getU2();
      float v2 = region.getV();
      vertices[X1] = x1;
      vertices[Y1] = y1;
      vertices[C1] = color;
      vertices[U1] = u1;
      vertices[V1] = v1;
      vertices[X2] = x1;
      vertices[Y2] = y2;
      vertices[C2] = color;
      vertices[U2] = u1;
      vertices[V2] = v2;
      vertices[X3] = x2;
      vertices[Y3] = y2;
      vertices[C3] = color;
      vertices[U3] = u2;
      vertices[V3] = v2;
      vertices[X4] = x2;
      vertices[Y4] = y1;
      vertices[C4] = color;
      vertices[U4] = u2;
      vertices[V4] = v1;
      if (flipX)
      {
        float temp = vertices[U1];
        vertices[U1] = vertices[U3];
        vertices[U3] = temp;
        temp = vertices[U2];
        vertices[U2] = vertices[U4];
        vertices[U4] = temp;
      }
      if (flipY)
      {
        float temp = vertices[V1];
        vertices[V1] = vertices[V3];
        vertices[V3] = temp;
        temp = vertices[V2];
        vertices[V2] = vertices[V4];
        vertices[V4] = temp;
      }
      if (rotations != 0)
      {
        switch (rotations)
        {
          case Cell.ROTATE_90:
            {
              float tempV = vertices[V1];
              vertices[V1] = vertices[V2];
              vertices[V2] = vertices[V3];
              vertices[V3] = vertices[V4];
              vertices[V4] = tempV;
              float tempU = vertices[U1];
              vertices[U1] = vertices[U2];
              vertices[U2] = vertices[U3];
              vertices[U3] = vertices[U4];
              vertices[U4] = tempU;
              break;
            }
          case Cell.ROTATE_180:
            {
              float tempU = vertices[U1];
              vertices[U1] = vertices[U3];
              vertices[U3] = tempU;
              tempU = vertices[U2];
              vertices[U2] = vertices[U4];
              vertices[U4] = tempU;
              float tempV = vertices[V1];
              vertices[V1] = vertices[V3];
              vertices[V3] = tempV;
              tempV = vertices[V2];
              vertices[V2] = vertices[V4];
              vertices[V4] = tempV;
              break;
            }
          case Cell.ROTATE_270:
            {
              float tempV = vertices[V1];
              vertices[V1] = vertices[V4];
              vertices[V4] = vertices[V3];
              vertices[V3] = vertices[V2];
              vertices[V2] = tempV;
              float tempU = vertices[U1];
              vertices[U1] = vertices[U4];
              vertices[U4] = vertices[U3];
              vertices[U3] = vertices[U2];
              vertices[U2] = tempU;
              break;
            }
        }
      }
      spriteBatch.draw(region.getTexture(), vertices, 0, 20);
    }
  }
}

Edit B:
Hole 1:
[SCond]: spriteBatch.setColor(1, 1, 1, layer.getOpacity());
Hole 2:
[SCond,SCond]: final int x1 = Math.max(0, ((int) (camLeft / layerTileWidth)));
Hole 3:
[SCond,SCond]: final int x2 = Math.min(layerWidth, ((int) ((camRight + layerTileWidth) / layerTileWidth)));
Hole 4:
[SCond,SCond]: final int y1 = Math.max(0, ((int) (camBottom / layerTileHeight)));
Hole 5:
[SCond,SCond]: final int y2 = Math.min(layerHeight, ((int) ((camTop + layerTileHeight) / layerTileHeight)));
Hole 6:
[SCond,SCond]: for (int x = x1 ; x < x2 ; x++)
{
  for (int y = y1 ; y < y2 ; y++)
  {
    final TiledMapTileLayer.Cell cell = tileLayer.getCell(x, y);
    final TiledMapTile tile = cell.getTile();
    if (tile != null)
    {
      final boolean flipX = cell.getFlipHorizontally();
      final boolean flipY = cell.getFlipVertically();
      final float rotate = cell.getRotation();
      TextureRegion region = tile.getTextureRegion();
      float drawX = x * layerTileWidth;
      float drawY = y * layerTileHeight;
      float width = region.getRegionWidth() * unitScale;
      float height = region.getRegionHeight() * unitScale;
      float originX = width * 0.5F;
      float originY = height * 0.5F;
      float scaleX = 1;
      float scaleY = 1;
      float rotation = 0;
      int sourceX = region.getRegionX();
      int sourceY = region.getRegionY();
      int sourceWidth = region.getRegionWidth();
      int sourceHeight = region.getRegionHeight();
      if (flipX)
      {
        sourceX += sourceWidth;
        sourceWidth = -sourceWidth;
      }
      if (flipY)
      {
        sourceY += sourceHeight;
        sourceHeight = -sourceHeight;
      }
      if (rotation == 0)
      {
        spriteBatch.draw(region.getTexture(), drawX, drawY, width, height, sourceX, sourceY, sourceWidth, sourceHeight, false, false);
      }
      else
      {
        spriteBatch.draw(region.getTexture(), drawX, drawY, originX, originY, width, height, scaleX, scaleY, rotate, sourceX, sourceY, sourceWidth, sourceHeight, false, false);
      }
    }
  }
}

Edit M:
Hole 1:
[SCond]: float color = Color.toFloatBits(1, 1, 1, layer.getOpacity());
Hole 2:
[SCond,SCond]: final int col1 = Math.max(0, ((int) (camLeft / layerTileWidth)));
Hole 3:
[SCond,SCond]: final int col2 = Math.min(layerWidth, ((int) ((camRight + layerTileWidth) / layerTileWidth)));
Hole 4:
[SCond,SCond]: final int row1 = Math.max(0, ((int) (camBottom / layerTileHeight)));
Hole 5:
[SCond,SCond]: final int row2 = Math.min(layerHeight, ((int) ((camTop + layerTileHeight) / layerTileHeight)));
Hole 6:
[SCond,SCond]: for (int row = row1 ; row < row2 ; row++)
{
  for (int col = col1 ; col < col2 ; col++)
  {
    final TiledMapTileLayer.Cell cell = tileLayer.getCell(col, row);
    final TiledMapTile tile = cell.getTile();
    if (tile != null)
    {
      final boolean flipX = cell.getFlipHorizontally();
      final boolean flipY = cell.getFlipVertically();
      final int rotations = cell.getRotation();
      TextureRegion region = tile.getTextureRegion();
      float x1 = col * layerTileWidth;
      float y1 = row * layerTileHeight;
      float x2 = (x1 + region.getRegionWidth()) * unitScale;
      float y2 = (y1 + region.getRegionHeight()) * unitScale;
      float u1 = region.getU();
      float v1 = region.getV2();
      float u2 = region.getU2();
      float v2 = region.getV();
      vertices[X1] = x1;
      vertices[Y1] = y1;
      vertices[C1] = color;
      vertices[U1] = u1;
      vertices[V1] = v1;
      vertices[X2] = x1;
      vertices[Y2] = y2;
      vertices[C2] = color;
      vertices[U2] = u1;
      vertices[V2] = v2;
      vertices[X3] = x2;
      vertices[Y3] = y2;
      vertices[C3] = color;
      vertices[U3] = u2;
      vertices[V3] = v2;
      vertices[X4] = x2;
      vertices[Y4] = y1;
      vertices[C4] = color;
      vertices[U4] = u2;
      vertices[V4] = v1;
      if (flipX)
      {
        float temp = vertices[U1];
        vertices[U1] = vertices[U3];
        vertices[U3] = temp;
        temp = vertices[U2];
        vertices[U2] = vertices[U4];
        vertices[U4] = temp;
      }
      if (flipY)
      {
        float temp = vertices[V1];
        vertices[V1] = vertices[V3];
        vertices[V3] = temp;
        temp = vertices[V2];
        vertices[V2] = vertices[V4];
        vertices[V4] = temp;
      }
      if (rotations != 0)
      {
        switch (rotations)
        {
          case Cell.ROTATE_90:
            {
              float tempV = vertices[V1];
              vertices[V1] = vertices[V2];
              vertices[V2] = vertices[V3];
              vertices[V3] = vertices[V4];
              vertices[V4] = tempV;
              float tempU = vertices[U1];
              vertices[U1] = vertices[U2];
              vertices[U2] = vertices[U3];
              vertices[U3] = vertices[U4];
              vertices[U4] = tempU;
              break;
            }
          case Cell.ROTATE_180:
            {
              float tempU = vertices[U1];
              vertices[U1] = vertices[U3];
              vertices[U3] = tempU;
              tempU = vertices[U2];
              vertices[U2] = vertices[U4];
              vertices[U4] = tempU;
              float tempV = vertices[V1];
              vertices[V1] = vertices[V3];
              vertices[V3] = tempV;
              tempV = vertices[V2];
              vertices[V2] = vertices[V4];
              vertices[V4] = tempV;
              break;
            }
          case Cell.ROTATE_270:
            {
              float tempV = vertices[V1];
              vertices[V1] = vertices[V4];
              vertices[V4] = vertices[V3];
              vertices[V3] = vertices[V2];
              vertices[V2] = tempV;
              float tempU = vertices[U1];
              vertices[U1] = vertices[U4];
              vertices[U4] = vertices[U3];
              vertices[U3] = vertices[U2];
              vertices[U2] = tempU;
              break;
            }
        }
      }
      spriteBatch.draw(region.getTexture(), vertices, 0, 20);
    }
  }
}


