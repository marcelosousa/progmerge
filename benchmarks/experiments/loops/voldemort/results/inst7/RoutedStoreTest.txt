Parsing files...
Merge Instance for method (Ident "RoutedStoreTest",Ident "countOccurances",[RefType (ClassRefType (ClassType [(Ident "RoutedStore",[])])),RefType (ClassRefType (ClassType [(Ident "ByteArray",[])])),RefType (ClassRefType (ClassType [(Ident "Versioned",[ActualType (ArrayType (PrimType ByteT))])]))])
private int countOccurances (RoutedStore routedStore, ByteArray key, Versioned<byte[]> value)
{
  int count = 0;
  <?HOLE?>
  return count;
}
Edit Base:
Hole 1:
[SLoop]: for (Store<ByteArray, byte[]> store : routedStore.getInnerStores().values()) try
                                                                             {
                                                                               if (store.get(key).size() > 0 && Utils.deepEquals(store.get(key).get(0), value))
                                                                                 count += 1;
                                                                             }
                                                                             catch (VoldemortException e)
                                                                             {
                                                                             }

Edit A:
Hole 1:
[SLoop]: for (Store<ByteArray, byte[], byte[]> store : routedStore.getInnerStores().values()) try
                                                                                     {
                                                                                       if (store.get(key, null).size() > 0 && Utils.deepEquals(store.get(key, null).get(0), value))
                                                                                         count += 1;
                                                                                     }
                                                                                     catch (VoldemortException e)
                                                                                     {
                                                                                     }

Edit B:
Hole 1:
[]: for (Store<ByteArray, byte[]> store : routedStore.getInnerStores().values()) try
                                                                             {
                                                                               if (store.get(key).size() > 0 && Utils.deepEquals(store.get(key).get(0), value))
                                                                                 count += 1;
                                                                             }
                                                                             catch (VoldemortException e)
                                                                             {
                                                                             }

Edit M:
Hole 1:
[]: for (Store<ByteArray, byte[], byte[]> store : routedStore.getInnerStores().values()) try
                                                                                     {
                                                                                       if (store.get(key, null).size() > 0 && Utils.deepEquals(store.get(key, null).get(0), value))
                                                                                         count += 1;
                                                                                     }
                                                                                     catch (VoldemortException e)
                                                                                     {
                                                                                     }

Merge Instance for method (Ident "RoutedStoreTest",Ident "testPutTimeout",[])
@Test
 public void testPutTimeout () throws Exception
{
  int timeout = 50;
  StoreDefinition definition = new StoreDefinitionBuilder().setName("test").setType("foo").setKeySerializer(new SerializerDefinition("test")).setValueSerializer(new SerializerDefinition("test")).setRoutingPolicy(RoutingTier.CLIENT).setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY).setReplicationFactor(3).setPreferredReads(3).setRequiredReads(3).setPreferredWrites(3).setRequiredWrites(3).build();
  <?HOLE?>
  List<Node> nodes = new ArrayList<Node>();
  int totalDelay = 0;
  for (int i = 0 ; i < 3 ; i++)
  {
    int delay = (4 + i) * timeout;
    totalDelay += delay;
    <?HOLE?>
    stores.put(i, store);
    List<Integer> partitions = Arrays.asList(i);
    nodes.add(new Node(i, "none", 0, 0, 0, partitions));
  }
  setFailureDetector(stores);
  routedStoreThreadPool = Executors.newFixedThreadPool(3);
  RoutedStoreFactory routedStoreFactory = new RoutedStoreFactory(isPipelineRoutedStoreEnabled, routedStoreThreadPool, timeout);
  RoutedStore routedStore = routedStoreFactory.create(new Cluster("test", nodes), definition, stores, true, failureDetector);
  <?HOLE?>
  <?HOLE?>
}
Edit Base:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[]> store = new SleepyStore<ByteArray, byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[]>("test"));
Hole 3:
[]: long start = System.currentTimeMillis();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }));
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = System.currentTimeMillis() - start;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Edit A:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[], byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[], byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[], byte[]> store = new SleepyStore<ByteArray, byte[], byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[], byte[]>("test"));
Hole 3:
[]: long start = System.currentTimeMillis();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }), null);
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = System.currentTimeMillis() - start;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Edit B:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[]> store = new SleepyStore<ByteArray, byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[]>("test"));
Hole 3:
[]: long start = System.nanoTime();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }));
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = (System.nanoTime() - start) / Time.NS_PER_MS;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Edit M:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[], byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[], byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[], byte[]> store = new SleepyStore<ByteArray, byte[], byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[], byte[]>("test"));
Hole 3:
[]: long start = System.nanoTime();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }), null);
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = (System.nanoTime() - start) / Time.NS_PER_MS;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Merge Instance for method (Ident "RoutedStoreTest",Ident "testReadRepairWithFailures",[])
@Test
 public void testReadRepairWithFailures () throws Exception
{
  cluster = getNineNodeCluster();
  RoutedStore routedStore = getStore(cluster, (cluster.getNumberOfNodes() - 1), (cluster.getNumberOfNodes() - 1), 1, 0);
  recordException(failureDetector, Iterables.get(cluster.getNodes(), 1));
  <?HOLE?>
  <?HOLE?>
  byte[] anotherValue = "john".getBytes();
  recordException(failureDetector, Iterables.getLast(cluster.getNodes()));
  recordSuccess(failureDetector, Iterables.get(cluster.getNodes(), 1));
  VectorClock clock = getClock(1);
  <?HOLE?>
  recordException(failureDetector, Iterables.get(cluster.getNodes(), 1));
  recordSuccess(failureDetector, Iterables.getLast(cluster.getNodes()));
  <?HOLE?>
  assertEquals(1, versioneds.size());
  assertEquals(new ByteArray(anotherValue), new ByteArray(versioneds.get(0).getValue()));
  Thread.sleep(100);
  <?HOLE?>
}
Edit Base:
Hole 1:
[]: Store<ByteArray, byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue));
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock));
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey);
Hole 5:
[SLoop]: for (Store<ByteArray, byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                    List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey);
                                                                                    assertEquals(1, versioneds.size());
                                                                                    assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                  }

Edit A:
Hole 1:
[]: Store<ByteArray, byte[], byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[], byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue), null);
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock), null);
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey, null);
Hole 5:
[SLoop]: for (Store<ByteArray, byte[], byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                            List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey, null);
                                                                                            assertEquals(1, versioneds.size());
                                                                                            assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                          }

Edit B:
Hole 1:
[]: Store<ByteArray, byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue));
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock));
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey);
Hole 5:
[]: for (Store<ByteArray, byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                    List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey);
                                                                                    assertEquals(1, versioneds.size());
                                                                                    assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                  }

Edit M:
Hole 1:
[]: Store<ByteArray, byte[], byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[], byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue), null);
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock), null);
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey, null);
Hole 5:
[]: for (Store<ByteArray, byte[], byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                            List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey, null);
                                                                                            assertEquals(1, versioneds.size());
                                                                                            assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                          }


