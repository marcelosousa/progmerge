Parsing files...
Merge Instance for method (Ident "RoutedStoreTest",Ident "countOccurances",[RefType (ClassRefType (ClassType [(Ident "RoutedStore",[])])),RefType (ClassRefType (ClassType [(Ident "ByteArray",[])])),RefType (ClassRefType (ClassType [(Ident "Versioned",[ActualType (ArrayType (PrimType ByteT))])]))])
private int countOccurances (RoutedStore routedStore, ByteArray key, Versioned<byte[]> value)
{
  int count = 0;
  <?HOLE?>
  return count;
}
Edit Base:
Hole 1:
[SLoop]: for (Store<ByteArray, byte[]> store : routedStore.getInnerStores().values()) try
                                                                             {
                                                                               if (store.get(key).size() > 0 && Utils.deepEquals(store.get(key).get(0), value))
                                                                                 count += 1;
                                                                             }
                                                                             catch (VoldemortException e)
                                                                             {
                                                                             }

Edit A:
Hole 1:
[SLoop]: for (Store<ByteArray, byte[], byte[]> store : routedStore.getInnerStores().values()) try
                                                                                     {
                                                                                       if (store.get(key, null).size() > 0 && Utils.deepEquals(store.get(key, null).get(0), value))
                                                                                         count += 1;
                                                                                     }
                                                                                     catch (VoldemortException e)
                                                                                     {
                                                                                     }

Edit B:
Hole 1:
[]: for (Store<ByteArray, byte[]> store : routedStore.getInnerStores().values()) try
                                                                             {
                                                                               if (store.get(key).size() > 0 && Utils.deepEquals(store.get(key).get(0), value))
                                                                                 count += 1;
                                                                             }
                                                                             catch (VoldemortException e)
                                                                             {
                                                                             }

Edit M:
Hole 1:
[]: for (Store<ByteArray, byte[], byte[]> store : routedStore.getInnerStores().values()) try
                                                                                     {
                                                                                       if (store.get(key, null).size() > 0 && Utils.deepEquals(store.get(key, null).get(0), value))
                                                                                         count += 1;
                                                                                     }
                                                                                     catch (VoldemortException e)
                                                                                     {
                                                                                     }

Merge Instance for method (Ident "RoutedStoreTest",Ident "testReadRepairWithFailures",[])
@Test
 public void testReadRepairWithFailures () throws Exception
{
  cluster = getNineNodeCluster();
  RoutedStore routedStore = getStore(cluster, (cluster.getNumberOfNodes() - 1), (cluster.getNumberOfNodes() - 1), 1, 0);
  recordException(failureDetector, Iterables.get(cluster.getNodes(), 1));
  <?HOLE?>
  <?HOLE?>
  byte[] anotherValue = "john".getBytes();
  recordException(failureDetector, Iterables.getLast(cluster.getNodes()));
  recordSuccess(failureDetector, Iterables.get(cluster.getNodes(), 1));
  VectorClock clock = getClock(1);
  <?HOLE?>
  recordException(failureDetector, Iterables.get(cluster.getNodes(), 1));
  recordSuccess(failureDetector, Iterables.getLast(cluster.getNodes()));
  <?HOLE?>
  assertEquals(1, versioneds.size());
  assertEquals(new ByteArray(anotherValue), new ByteArray(versioneds.get(0).getValue()));
  Thread.sleep(100);
  <?HOLE?>
}
Edit Base:
Hole 1:
[]: Store<ByteArray, byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue));
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock));
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey);
Hole 5:
[SLoop]: for (Store<ByteArray, byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                    List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey);
                                                                                    assertEquals(1, versioneds.size());
                                                                                    assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                  }

Edit A:
Hole 1:
[]: Store<ByteArray, byte[], byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[], byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue), aTransform);
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock), aTransform);
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey, aTransform);
Hole 5:
[SLoop]: for (Store<ByteArray, byte[], byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                            List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey, aTransform);
                                                                                            assertEquals(1, versioneds.size());
                                                                                            assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                          }

Edit B:
Hole 1:
[]: Store<ByteArray, byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue));
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock));
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey);
Hole 5:
[]: for (Store<ByteArray, byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                    List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey);
                                                                                    assertEquals(1, versioneds.size());
                                                                                    assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                  }

Edit M:
Hole 1:
[]: Store<ByteArray, byte[], byte[]> store = new InconsistencyResolvingStore<ByteArray, byte[], byte[]>(routedStore, new VectorClockInconsistencyResolver<byte[]>());
Hole 2:
[]: store.put(aKey, new Versioned<byte[]>(aValue), aTransform);
Hole 3:
[]: store.put(aKey, new Versioned<byte[]>(anotherValue, clock), aTransform);
Hole 4:
[]: List<Versioned<byte[]>> versioneds = store.get(aKey, aTransform);
Hole 5:
[]: for (Store<ByteArray, byte[], byte[]> innerStore : routedStore.getInnerStores().values()) {
                                                                                            List<Versioned<byte[]>> innerVersioneds = innerStore.get(aKey, aTransform);
                                                                                            assertEquals(1, versioneds.size());
                                                                                            assertEquals(new ByteArray(anotherValue), new ByteArray(innerVersioneds.get(0).getValue()));
                                                                                          }


