Parsing files...
Merge Instance for method (Ident "Measurement",Ident "generateResults",[])
public Results generateResults ()
{
  int median = 0, q95 = 0, q99 = 0;
  int opcounter = 0;
  boolean done95th = false, done50th = false;
  <?HOLE?>
  return new Results(operations, minLatency, maxLatency, totalLatency, median, q95, q99);
}
Edit Base:
Hole 1:
[SLoop]: for (int i = 0 ; i < _buckets ; i++)
{
  opcounter += histogram[i];
  double currentQuartile = (double) opcounter / (double) operations;
  if ((!done50th && currentQuartile) >= 0.5)
  {
    median = i;
    done50th = true;
  }
  if ((!done95th && currentQuartile) >= 0.95)
  {
    q95 = i;
    done95th = true;
  }
  if (currentQuartile >= 0.99)
  {
    q99 = i;
    break;
  }
}

Edit A:
Hole 1:
[SLoop]: for (int i = 0 ; i < buckets ; i++)
{
  opcounter += histogram[i];
  double currentQuartile = (double) opcounter / (double) operations;
  if ((!done50th && currentQuartile) >= 0.5)
  {
    median = i;
    done50th = true;
  }
  if ((!done95th && currentQuartile) >= 0.95)
  {
    q95 = i;
    done95th = true;
  }
  if (currentQuartile >= 0.99)
  {
    q99 = i;
    break;
  }
}

Edit B:
Hole 1:
[]: for (int i = 0 ; i < _buckets ; i++)
{
  opcounter += histogram[i];
  double currentQuartile = (double) opcounter / (double) operations;
  if ((!done50th && currentQuartile) >= 0.5)
  {
    median = i;
    done50th = true;
  }
  if ((!done95th && currentQuartile) >= 0.95)
  {
    q95 = i;
    done95th = true;
  }
  if (currentQuartile >= 0.99)
  {
    q99 = i;
    break;
  }
}

Edit M:
Hole 1:
[]: for (int i = 0 ; i < buckets ; i++)
{
  opcounter += histogram[i];
  double currentQuartile = (double) opcounter / (double) operations;
  if ((!done50th && currentQuartile) >= 0.5)
  {
    median = i;
    done50th = true;
  }
  if ((!done95th && currentQuartile) >= 0.95)
  {
    q95 = i;
    done95th = true;
  }
  if (currentQuartile >= 0.99)
  {
    q99 = i;
    break;
  }
}

Merge Instance for method (Ident "Measurement",Ident "printReport",[RefType (ClassRefType (ClassType [(Ident "PrintStream",[])]))])
public void printReport (PrintStream out)
{
  Results result = generateResults();
  NumberFormat nf = NumberFormat.getInstance();
  nf.setMaximumFractionDigits(4);
  <?HOLE?>
  out.println(("[" + getName() + "]\tOperations: " + operations));
  out.println(("[" + getName() + "]\tAverage(ms): " + nf.format(((double) totalLatency / (double) operations))));
  out.println(("[" + getName() + "]\tMin(ms): " + nf.format(minLatency)));
  out.println(("[" + getName() + "]\tMax(ms): " + nf.format(maxLatency)));
  out.println(("[" + getName() + "]\tMedian(ms): " + nf.format(result.medianLatency)));
  out.println(("[" + getName() + "]\t95th(ms): " + nf.format(result.q95Latency)));
  out.println(("[" + getName() + "]\t99th(ms): " + nf.format(result.q99Latency)));
  if (!this.summaryOnly)
  {
    for (Integer I : returnCodes.keySet()) {
                                             int[] val = returnCodes.get(I);
                                             out.println(("[" + getName() + "]\tReturn: " + I + "\t" + val[0]));
                                           }
    <?HOLE?>
    <?HOLE?>
  }
}
Edit Base:
Hole 1:
[]: <SKIP>
Hole 2:
[SLoop,SCond]: for (int i = 0 ; i < _buckets ; i++)
{
  out.println(("[" + getName() + "]: " + i + "\t" + histogram[i]));
}
Hole 3:
[SCond]: out.println(("[" + getName() + "]: >" + _buckets + "\t" + histogramOverflow));

Edit A:
Hole 1:
[]: <SKIP>
Hole 2:
[SLoop,SCond]: for (int i = 0 ; i < buckets ; i++)
{
  out.println(("[" + getName() + "]: " + i + "\t" + histogram[i]));
}
Hole 3:
[SCond]: out.println(("[" + getName() + "]: >" + buckets + "\t" + histogramOverflow));

Edit B:
Hole 1:
[]: nf.setGroupingUsed(false);
Hole 2:
[SCond]: for (int i = 0 ; i < _buckets ; i++)
{
  out.println(("[" + getName() + "]: " + i + "\t" + histogram[i]));
}
Hole 3:
[SCond]: out.println(("[" + getName() + "]: >" + _buckets + "\t" + histogramOverflow));

Edit M:
Hole 1:
[]: nf.setGroupingUsed(false);
Hole 2:
[SCond]: for (int i = 0 ; i < buckets ; i++)
{
  out.println(("[" + getName() + "]: " + i + "\t" + histogram[i]));
}
Hole 3:
[SCond]: out.println(("[" + getName() + "]: >" + buckets + "\t" + histogramOverflow));


