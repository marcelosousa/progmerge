Parsing files...
Merge Instance for method (Ident "VoldemortAdminTool",Ident "executeFetchEntries",[RefType (ClassRefType (ClassType [(Ident "Integer",[])])),RefType (ClassRefType (ClassType [(Ident "AdminClient",[])])),RefType (ClassRefType (ClassType [(Ident "List",[ActualType (ClassRefType (ClassType [(Ident "Integer",[])]))])])),RefType (ClassRefType (ClassType [(Ident "String",[])])),RefType (ClassRefType (ClassType [(Ident "List",[ActualType (ClassRefType (ClassType [(Ident "String",[])]))])])),PrimType BooleanT])
private static void executeFetchEntries (Integer nodeId, AdminClient adminClient, List<Integer> partitionIdList, String outputDir, List<String> storeNames, boolean useAscii) throws IOException
{
  List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
  <?HOLE?>
  for (StoreDefinition storeDefinition : storeDefinitionList) {
                                                                storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
                                                              }
  File directory = null;
  if (outputDir != null)
  {
    directory = new File(outputDir);
    if (!(directory.exists() || directory.mkdir()))
    {
      Utils.croak(("Can't find or create directory " + outputDir));
    }
  }
  List<String> stores = storeNames;
  <?HOLE?>
  if (partitionIdList == null)
  {
    partitionIdList = Lists.newArrayList();
    for (Node node : adminClient.getAdminClientCluster().getNodes()) {
                                                                       partitionIdList.addAll(node.getPartitionIds());
                                                                     }
  }
  StoreDefinition storeDefinition = null;
  for (String store : stores) {
                                storeDefinition = storeDefinitionMap.get(store);
                                if (null == storeDefinition)
                                {
                                  System.out.println(("No store found under the name '" + store + "'"));
                                  continue;
                                }
                                else
                                {
                                  System.out.println(("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store));
                                }
                                <?HOLE?>
                                File outputFile = null;
                                if (directory != null)
                                {
                                  outputFile = new File(directory, store + ".entries");
                                }
                                if (useAscii)
                                {
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                }
                                else
                                {
                                  <?HOLE?>
                                }
                                if (outputFile != null)
                                  System.out.println(("Fetched keys from " + store + " to " + outputFile));
                              }
}
Edit Base:
Hole 1:
[]: Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
Hole 2:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
Hole 3:
[SLoop]: Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId, store, partitionIdList, null, false);
Hole 4:
[SCond,SLoop]: writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
Hole 5:
[SCond,SLoop]: <SKIP>
Hole 6:
[SCond,SLoop]: <SKIP>
Hole 7:
[SCond,SLoop]: <SKIP>
Hole 8:
[SCond,SLoop]: <SKIP>
Hole 9:
[SCond,SLoop]: <SKIP>
Hole 10:
[SCond,SLoop]: <SKIP>
Hole 11:
[SCond,SLoop]: <SKIP>
Hole 12:
[SCond,SLoop]: <SKIP>
Hole 13:
[SCond,SLoop]: <SKIP>
Hole 14:
[SCond,SLoop]: writeEntriesBinary(entriesIterator, outputFile);

Edit A:
Hole 1:
[]: HashMap<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
Hole 2:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
else
{
  storeDefinitionMap.putAll(getSystemStoreDefs());
}
Hole 3:
[SLoop]: Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId, store, partitionIdList, null, false);
Hole 4:
[SCond,SLoop]: writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
Hole 5:
[SCond,SLoop]: <SKIP>
Hole 6:
[SCond,SLoop]: <SKIP>
Hole 7:
[SCond,SLoop]: <SKIP>
Hole 8:
[SCond,SLoop]: <SKIP>
Hole 9:
[SCond,SLoop]: <SKIP>
Hole 10:
[SCond,SLoop]: <SKIP>
Hole 11:
[SCond,SLoop]: <SKIP>
Hole 12:
[SCond,SLoop]: <SKIP>
Hole 13:
[SCond,SLoop]: <SKIP>
Hole 14:
[SCond,SLoop]: writeEntriesBinary(entriesIterator, outputFile);

Edit B:
Hole 1:
[]: Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
Hole 2:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
Hole 3:
[SLoop]: final Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId, store, partitionIdList, null, false);
Hole 4:
[SCond,SLoop]: SerializerDefinition keySerializerDef = storeDefinition.getKeySerializer();
Hole 5:
[SCond,SLoop]: SerializerDefinition valueSerializerDef = storeDefinition.getValueSerializer();
Hole 6:
[SCond,SLoop]: SerializerFactory serializerFactory = new DefaultSerializerFactory();
Hole 7:
[SCond,SLoop]: @SuppressWarnings("unchecked")
 final Serializer<Object> keySerializer = (Serializer<Object>) serializerFactory.getSerializer(keySerializerDef);
Hole 8:
[SCond,SLoop]: @SuppressWarnings("unchecked")
 final Serializer<Object> valueSerializer = (Serializer<Object>) serializerFactory.getSerializer(valueSerializerDef);
Hole 9:
[SCond,SLoop]: final CompressionStrategy keyCompressionStrategy;
Hole 10:
[SCond,SLoop]: final CompressionStrategy valueCompressionStrategy;
Hole 11:
[SCond,SLoop]: if (keySerializerDef != null && keySerializerDef.hasCompression())
{
  keyCompressionStrategy = new CompressionStrategyFactory().get(keySerializerDef.getCompression());
}
else
{
  keyCompressionStrategy = null;
}
Hole 12:
[SCond,SLoop]: if (valueSerializerDef != null && valueSerializerDef.hasCompression())
{
  valueCompressionStrategy = new CompressionStrategyFactory().get(valueSerializerDef.getCompression());
}
else
{
  valueCompressionStrategy = null;
}
Hole 13:
[SCond,SLoop]: writeAscii(outputFile, new Writable()
                       {
                         @Override
                         public void writeTo (BufferedWriter out) throws IOException
                         {
                           final StringWriter stringWriter = new StringWriter();
                           final JsonGenerator generator = new JsonFactory(new ObjectMapper()).createJsonGenerator(stringWriter);
                           while (entriesIterator.hasNext())
                           {
                             Pair<ByteArray, Versioned<byte[]>> kvPair = entriesIterator.next();
                             byte[] keyBytes = kvPair.getFirst().get();
                             byte[] valueBytes = kvPair.getSecond().getValue();
                             VectorClock version = (VectorClock) kvPair.getSecond().getVersion();
                             Object keyObject = keySerializer.toObject((null == keyCompressionStrategy ? keyBytes : keyCompressionStrategy.inflate(keyBytes)));
                             Object valueObject = valueSerializer.toObject((null == valueCompressionStrategy ? valueBytes : valueCompressionStrategy.inflate(valueBytes)));
                             generator.writeObject(keyObject);
                             stringWriter.write(' ');
                             stringWriter.write(version.toString());
                             generator.writeObject(valueObject);
                             StringBuffer buf = stringWriter.getBuffer();
                             if (buf.charAt(0) == ' ')
                             {
                               buf.setCharAt(0, '\n');
                             }
                             out.write(buf.toString());
                             buf.setLength(0);
                           }
                           out.write('\n');
                         }
                       });
Hole 14:
[SCond,SLoop]: writeBinary(outputFile, new Printable()
                        {
                          @Override
                          public void printTo (DataOutputStream out) throws IOException
                          {
                            while (entriesIterator.hasNext())
                            {
                              Pair<ByteArray, Versioned<byte[]>> kvPair = entriesIterator.next();
                              byte[] keyBytes = kvPair.getFirst().get();
                              byte[] versionBytes = ((VectorClock) kvPair.getSecond().getVersion()).toBytes();
                              byte[] valueBytes = kvPair.getSecond().getValue();
                              out.writeInt(keyBytes.length);
                              out.write(keyBytes);
                              out.writeInt(versionBytes.length);
                              out.write(versionBytes);
                              out.writeInt(valueBytes.length);
                              out.write(valueBytes);
                            }
                          }
                        });

Edit M:
Hole 1:
[]: HashMap<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
Hole 2:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
else
{
  storeDefinitionMap.putAll(getSystemStoreDefs());
}
Hole 3:
[SLoop]: final Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId, store, partitionIdList, null, false);
Hole 4:
[SCond,SLoop]: SerializerDefinition keySerializerDef = storeDefinition.getKeySerializer();
Hole 5:
[SCond,SLoop]: SerializerDefinition valueSerializerDef = storeDefinition.getValueSerializer();
Hole 6:
[SCond,SLoop]: SerializerFactory serializerFactory = new DefaultSerializerFactory();
Hole 7:
[SCond,SLoop]: @SuppressWarnings("unchecked")
 final Serializer<Object> keySerializer = (Serializer<Object>) serializerFactory.getSerializer(keySerializerDef);
Hole 8:
[SCond,SLoop]: @SuppressWarnings("unchecked")
 final Serializer<Object> valueSerializer = (Serializer<Object>) serializerFactory.getSerializer(valueSerializerDef);
Hole 9:
[SCond,SLoop]: final CompressionStrategy keyCompressionStrategy;
Hole 10:
[SCond,SLoop]: final CompressionStrategy valueCompressionStrategy;
Hole 11:
[SCond,SLoop]: if (keySerializerDef != null && keySerializerDef.hasCompression())
{
  keyCompressionStrategy = new CompressionStrategyFactory().get(keySerializerDef.getCompression());
}
else
{
  keyCompressionStrategy = null;
}
Hole 12:
[SCond,SLoop]: if (valueSerializerDef != null && valueSerializerDef.hasCompression())
{
  valueCompressionStrategy = new CompressionStrategyFactory().get(valueSerializerDef.getCompression());
}
else
{
  valueCompressionStrategy = null;
}
Hole 13:
[SCond,SLoop]: writeAscii(outputFile, new Writable()
                       {
                         @Override
                         public void writeTo (BufferedWriter out) throws IOException
                         {
                           final StringWriter stringWriter = new StringWriter();
                           final JsonGenerator generator = new JsonFactory(new ObjectMapper()).createJsonGenerator(stringWriter);
                           while (entriesIterator.hasNext())
                           {
                             Pair<ByteArray, Versioned<byte[]>> kvPair = entriesIterator.next();
                             byte[] keyBytes = kvPair.getFirst().get();
                             byte[] valueBytes = kvPair.getSecond().getValue();
                             VectorClock version = (VectorClock) kvPair.getSecond().getVersion();
                             Object keyObject = keySerializer.toObject((null == keyCompressionStrategy ? keyBytes : keyCompressionStrategy.inflate(keyBytes)));
                             Object valueObject = valueSerializer.toObject((null == valueCompressionStrategy ? valueBytes : valueCompressionStrategy.inflate(valueBytes)));
                             generator.writeObject(keyObject);
                             stringWriter.write(' ');
                             stringWriter.write(version.toString());
                             generator.writeObject(valueObject);
                             StringBuffer buf = stringWriter.getBuffer();
                             if (buf.charAt(0) == ' ')
                             {
                               buf.setCharAt(0, '\n');
                             }
                             out.write(buf.toString());
                             buf.setLength(0);
                           }
                           out.write('\n');
                         }
                       });
Hole 14:
[SCond,SLoop]: writeBinary(outputFile, new Printable()
                        {
                          @Override
                          public void printTo (DataOutputStream out) throws IOException
                          {
                            while (entriesIterator.hasNext())
                            {
                              Pair<ByteArray, Versioned<byte[]>> kvPair = entriesIterator.next();
                              byte[] keyBytes = kvPair.getFirst().get();
                              byte[] versionBytes = ((VectorClock) kvPair.getSecond().getVersion()).toBytes();
                              byte[] valueBytes = kvPair.getSecond().getValue();
                              out.writeInt(keyBytes.length);
                              out.write(keyBytes);
                              out.writeInt(versionBytes.length);
                              out.write(versionBytes);
                              out.writeInt(valueBytes.length);
                              out.write(valueBytes);
                            }
                          }
                        });

Merge Instance for method (Ident "VoldemortAdminTool",Ident "executeFetchKeys",[RefType (ClassRefType (ClassType [(Ident "Integer",[])])),RefType (ClassRefType (ClassType [(Ident "AdminClient",[])])),RefType (ClassRefType (ClassType [(Ident "List",[ActualType (ClassRefType (ClassType [(Ident "Integer",[])]))])])),RefType (ClassRefType (ClassType [(Ident "String",[])])),RefType (ClassRefType (ClassType [(Ident "List",[ActualType (ClassRefType (ClassType [(Ident "String",[])]))])])),PrimType BooleanT])
private static void executeFetchKeys (Integer nodeId, AdminClient adminClient, List<Integer> partitionIdList, String outputDir, List<String> storeNames, boolean useAscii) throws IOException
{
  List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
  Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
  for (StoreDefinition storeDefinition : storeDefinitionList) {
                                                                storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
                                                              }
  File directory = null;
  if (outputDir != null)
  {
    directory = new File(outputDir);
    if (!(directory.exists() || directory.mkdir()))
    {
      Utils.croak(("Can't find or create directory " + outputDir));
    }
  }
  List<String> stores = storeNames;
  <?HOLE?>
  if (partitionIdList == null)
  {
    partitionIdList = Lists.newArrayList();
    for (Node node : adminClient.getAdminClientCluster().getNodes()) {
                                                                       partitionIdList.addAll(node.getPartitionIds());
                                                                     }
  }
  StoreDefinition storeDefinition = null;
  for (String store : stores) {
                                storeDefinition = storeDefinitionMap.get(store);
                                if (null == storeDefinition)
                                {
                                  System.out.println(("No store found under the name '" + store + "'"));
                                  continue;
                                }
                                else
                                {
                                  System.out.println(("Fetching keys in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store));
                                }
                                <?HOLE?>
                                File outputFile = null;
                                if (directory != null)
                                {
                                  outputFile = new File(directory, store + ".keys");
                                }
                                if (useAscii)
                                {
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                  <?HOLE?>
                                }
                                else
                                {
                                  <?HOLE?>
                                }
                                if (outputFile != null)
                                  System.out.println(("Fetched keys from " + store + " to " + outputFile));
                              }
}
Edit Base:
Hole 1:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
Hole 2:
[SLoop]: Iterator<ByteArray> keyIterator = adminClient.fetchKeys(nodeId, store, partitionIdList, null, false);
Hole 3:
[SCond,SLoop]: writeKeysAscii(keyIterator, outputFile, storeDefinition);
Hole 4:
[SCond,SLoop]: <SKIP>
Hole 5:
[SCond,SLoop]: <SKIP>
Hole 6:
[SCond,SLoop]: <SKIP>
Hole 7:
[SCond,SLoop]: <SKIP>
Hole 8:
[SCond,SLoop]: <SKIP>
Hole 9:
[SCond,SLoop]: writeKeysBinary(keyIterator, outputFile);

Edit A:
Hole 1:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
else
{
  storeDefinitionMap.putAll(getSystemStoreDefs());
}
Hole 2:
[SLoop]: Iterator<ByteArray> keyIterator = adminClient.fetchKeys(nodeId, store, partitionIdList, null, false);
Hole 3:
[SCond,SLoop]: writeKeysAscii(keyIterator, outputFile, storeDefinition);
Hole 4:
[SCond,SLoop]: <SKIP>
Hole 5:
[SCond,SLoop]: <SKIP>
Hole 6:
[SCond,SLoop]: <SKIP>
Hole 7:
[SCond,SLoop]: <SKIP>
Hole 8:
[SCond,SLoop]: <SKIP>
Hole 9:
[SCond,SLoop]: writeKeysBinary(keyIterator, outputFile);

Edit B:
Hole 1:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
Hole 2:
[SLoop]: final Iterator<ByteArray> keyIterator = adminClient.fetchKeys(nodeId, store, partitionIdList, null, false);
Hole 3:
[SCond,SLoop]: final SerializerDefinition serializerDef = storeDefinition.getKeySerializer();
Hole 4:
[SCond,SLoop]: final SerializerFactory serializerFactory = new DefaultSerializerFactory();
Hole 5:
[SCond,SLoop]: @SuppressWarnings("unchecked")
 final Serializer<Object> serializer = (Serializer<Object>) serializerFactory.getSerializer(serializerDef);
Hole 6:
[SCond,SLoop]: final CompressionStrategy keysCompressionStrategy;
Hole 7:
[SCond,SLoop]: if (serializerDef != null && serializerDef.hasCompression())
{
  keysCompressionStrategy = new CompressionStrategyFactory().get(serializerDef.getCompression());
}
else
{
  keysCompressionStrategy = null;
}
Hole 8:
[SCond,SLoop]: writeAscii(outputFile, new Writable()
                       {
                         @Override
                         public void writeTo (BufferedWriter out) throws IOException
                         {
                           final StringWriter stringWriter = new StringWriter();
                           final JsonGenerator generator = new JsonFactory(new ObjectMapper()).createJsonGenerator(stringWriter);
                           while (keyIterator.hasNext())
                           {
                             byte[] keyBytes = keyIterator.next().get();
                             Object keyObject = serializer.toObject((null == keysCompressionStrategy ? keyBytes : keysCompressionStrategy.inflate(keyBytes)));
                             generator.writeObject(keyObject);
                             StringBuffer buf = stringWriter.getBuffer();
                             if (buf.charAt(0) == ' ')
                             {
                               buf.setCharAt(0, '\n');
                             }
                             out.write(buf.toString());
                             buf.setLength(0);
                           }
                           out.write('\n');
                         }
                       });
Hole 9:
[SCond,SLoop]: writeBinary(outputFile, new Printable()
                        {
                          @Override
                          public void printTo (DataOutputStream out) throws IOException
                          {
                            while (keyIterator.hasNext())
                            {
                              byte[] keyBytes = keyIterator.next().get();
                              out.writeInt(keyBytes.length);
                              out.write(keyBytes);
                            }
                          }
                        });

Edit M:
Hole 1:
[]: if (stores == null)
{
  stores = Lists.newArrayList();
  stores.addAll(storeDefinitionMap.keySet());
}
else
{
  storeDefinitionMap.putAll(getSystemStoreDefs());
}
Hole 2:
[SLoop]: final Iterator<ByteArray> keyIterator = adminClient.fetchKeys(nodeId, store, partitionIdList, null, false);
Hole 3:
[SCond,SLoop]: final SerializerDefinition serializerDef = storeDefinition.getKeySerializer();
Hole 4:
[SCond,SLoop]: final SerializerFactory serializerFactory = new DefaultSerializerFactory();
Hole 5:
[SCond,SLoop]: @SuppressWarnings("unchecked")
 final Serializer<Object> serializer = (Serializer<Object>) serializerFactory.getSerializer(serializerDef);
Hole 6:
[SCond,SLoop]: final CompressionStrategy keysCompressionStrategy;
Hole 7:
[SCond,SLoop]: if (serializerDef != null && serializerDef.hasCompression())
{
  keysCompressionStrategy = new CompressionStrategyFactory().get(serializerDef.getCompression());
}
else
{
  keysCompressionStrategy = null;
}
Hole 8:
[SCond,SLoop]: writeAscii(outputFile, new Writable()
                       {
                         @Override
                         public void writeTo (BufferedWriter out) throws IOException
                         {
                           final StringWriter stringWriter = new StringWriter();
                           final JsonGenerator generator = new JsonFactory(new ObjectMapper()).createJsonGenerator(stringWriter);
                           while (keyIterator.hasNext())
                           {
                             byte[] keyBytes = keyIterator.next().get();
                             Object keyObject = serializer.toObject((null == keysCompressionStrategy ? keyBytes : keysCompressionStrategy.inflate(keyBytes)));
                             generator.writeObject(keyObject);
                             StringBuffer buf = stringWriter.getBuffer();
                             if (buf.charAt(0) == ' ')
                             {
                               buf.setCharAt(0, '\n');
                             }
                             out.write(buf.toString());
                             buf.setLength(0);
                           }
                           out.write('\n');
                         }
                       });
Hole 9:
[SCond,SLoop]: writeBinary(outputFile, new Printable()
                        {
                          @Override
                          public void printTo (DataOutputStream out) throws IOException
                          {
                            while (keyIterator.hasNext())
                            {
                              byte[] keyBytes = keyIterator.next().get();
                              out.writeInt(keyBytes.length);
                              out.write(keyBytes);
                            }
                          }
                        });


