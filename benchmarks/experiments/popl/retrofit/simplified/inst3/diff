Parsing files...
Merge Instance for method (Ident "RestMethodInfo",Ident "parseMethodAnnotations",[])
private void parseMethodAnnotations ()
{
  for (Annotation methodAnnotation : method.getAnnotations()) {
                                                                Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
                                                                RestMethod methodInfo = null;
                                                                for (Annotation innerAnnotation : annotationType.getAnnotations()) {
                                                                                                                                     if (RestMethod.class == innerAnnotation.annotationType())
                                                                                                                                     {
                                                                                                                                       methodInfo = (RestMethod) innerAnnotation;
                                                                                                                                       break;
                                                                                                                                     }
                                                                                                                                   }
                                                                if (methodInfo != null)
                                                                {
                                                                  <?HOLE?>
                                                                  <?HOLE?>
                                                                  <?HOLE?>
                                                                  <?HOLE?>
                                                                  <?HOLE?>
                                                                  <?HOLE?>
                                                                }
                                                                else
                                                                  <?HOLE?>
                                                              }
  <?HOLE?>
  <?HOLE?>
  <?HOLE?>
}
Edit Base:
Hole 1:
[SCond,SCond,SLoop]: if (restMethod != null)
{
  throw new IllegalArgumentException("Method contains multiple HTTP annotations.");
}
Hole 2:
[SCond,SLoop]: try
{
  path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
}
catch (Exception e)
{
  throw new RuntimeException("Failed to extract URI path.", e);
}
Hole 3:
[SCond,SLoop]: if (!path.startsWith("/"))
{
  throw new IllegalArgumentException("URL path must be prefixed with '/'.");
}
Hole 4:
[SCond,SLoop]: pathParams = parsePathParameters(path);
Hole 5:
[SCond,SLoop]: restMethod = methodInfo;
Hole 6:
[SCond,SLoop]: <SKIP>
Hole 7:
[SCond,SCond,SLoop]: if (annotationType == QueryParams.class)
{
  if (pathQueryParams != null)
  {
    throw new IllegalStateException("QueryParam and QueryParams annotations are mutually exclusive.");
  }
  pathQueryParams = ((QueryParams) methodAnnotation).value();
  if (pathQueryParams.length == 0)
  {
    throw new IllegalStateException("QueryParams annotation was empty.");
  }
}
else
  if (annotationType == QueryParam.class)
  {
    if (pathQueryParams != null)
    {
      throw new IllegalStateException("QueryParam and QueryParams annotations are mutually exclusive.");
    }
    pathQueryParams = new QueryParam[] {
                                         (QueryParam) methodAnnotation,
                                       };
  }
  else
    if (annotationType == Multipart.class)
    {
      isMultipart = true;
    }
Hole 8:
[SCond]: if (restMethod == null)
{
  throw new IllegalStateException("Method " + method + " not annotated with request type (e.g., GET, POST).");
}
Hole 9:
[SCond]: if (!restMethod.hasBody() && isMultipart)
{
  throw new IllegalStateException("Multipart can only be specific on HTTP methods with request body (e.g., POST).");
}
Hole 10:
[]: if (pathQueryParams == null)
{
  pathQueryParams = new QueryParam[0];
}
else
{
  for (QueryParam pathQueryParam : pathQueryParams) {
                                                      if (pathParams.contains(pathQueryParam.name()))
                                                      {
                                                        throw new IllegalStateException("Query parameters cannot be present in URL.");
                                                      }
                                                    }
}

Edit A:
Hole 1:
[SCond,SCond,SLoop]: if (requestMethod != null)
{
  throw new IllegalArgumentException("Method " + method.getName() + " contains multiple HTTP methods. Found: " + requestMethod + " and " + methodInfo.value());
}
Hole 2:
[SCond,SLoop]: String path;
Hole 3:
[SCond,SLoop]: try
{
  path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
}
catch (Exception e)
{
  throw new RuntimeException("Failed to extract path from " + annotationType.getSimpleName() + " annotation on " + method.getName() + ".", e);
}
Hole 4:
[SCond,SLoop]: parsePath(path);
Hole 5:
[SCond,SLoop]: requestMethod = methodInfo.value();
Hole 6:
[SCond,SLoop]: requestHasBody = methodInfo.hasBody();
Hole 7:
[SCond,SCond,SLoop]: if (annotationType == Multipart.class)
{
  requestType = RequestType.MULTIPART;
}
else
  if (annotationType == FormEncoded.class)
  {
    requestType = RequestType.FORM_ENCODED;
  }
Hole 8:
[SCond]: if (requestMethod == null)
{
  throw new IllegalStateException("Method " + method.getName() + " not annotated with request type (e.g., GET, POST).");
}
Hole 9:
[SCond]: if (!requestHasBody)
{
  if (requestType == RequestType.MULTIPART)
  {
    throw new IllegalStateException("Multipart can only be specific on HTTP methods with request body (e.g., POST). (" + method.getName() + ")");
  }
  if (requestType == RequestType.FORM_ENCODED)
  {
    throw new IllegalStateException("Multipart can only be specific on HTTP methods with request body (e.g., POST). (" + method.getName() + ")");
  }
}
Hole 10:
[]: <SKIP>

Edit B:
Hole 1:
[SCond,SLoop]: if (restMethod != null)
{
  throw new IllegalArgumentException("Method contains multiple HTTP annotations.");
}
Hole 2:
[SCond,SLoop]: try
{
  path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
}
catch (Exception e)
{
  throw new RuntimeException("Failed to extract URI path.", e);
}
Hole 3:
[SCond,SLoop]: if (!path.startsWith("/"))
{
  throw new IllegalArgumentException("URL path must be prefixed with '/'.");
}
Hole 4:
[SCond,SLoop]: pathParams = parsePathParameters(path);
Hole 5:
[SCond,SLoop]: restMethod = methodInfo;
Hole 6:
[SCond,SLoop]: <SKIP>
Hole 7:
[SCond,SLoop]: if (annotationType == Headers.class)
{
  String[] headersToParse = ((Headers) methodAnnotation).value();
  if (headersToParse.length == 0)
  {
    throw new IllegalStateException("Headers annotation was empty.");
  }
  headers = parseHeaders(headersToParse);
}
else
  if (annotationType == QueryParams.class)
  {
    if (pathQueryParams != null)
    {
      throw new IllegalStateException("QueryParam and QueryParams annotations are mutually exclusive.");
    }
    pathQueryParams = ((QueryParams) methodAnnotation).value();
    if (pathQueryParams.length == 0)
    {
      throw new IllegalStateException("QueryParams annotation was empty.");
    }
  }
  else
    if (annotationType == QueryParam.class)
    {
      if (pathQueryParams != null)
      {
        throw new IllegalStateException("QueryParam and QueryParams annotations are mutually exclusive.");
      }
      pathQueryParams = new QueryParam[] {
                                           (QueryParam) methodAnnotation,
                                         };
    }
    else
      if (annotationType == Multipart.class)
      {
        isMultipart = true;
      }
Hole 8:
[]: if (restMethod == null)
{
  throw new IllegalStateException("Method " + method + " not annotated with request type (e.g., GET, POST).");
}
Hole 9:
[]: if (!restMethod.hasBody() && isMultipart)
{
  throw new IllegalStateException("Multipart can only be specific on HTTP methods with request body (e.g., POST).");
}
Hole 10:
[]: if (pathQueryParams == null)
{
  pathQueryParams = new QueryParam[0];
}
else
{
  for (QueryParam pathQueryParam : pathQueryParams) {
                                                      if (pathParams.contains(pathQueryParam.name()))
                                                      {
                                                        throw new IllegalStateException("Query parameters cannot be present in URL.");
                                                      }
                                                    }
}

Edit M:
Hole 1:
[SCond,SLoop]: if (requestMethod != null)
{
  throw new IllegalArgumentException("Method " + method.getName() + " contains multiple HTTP methods. Found: " + requestMethod + " and " + methodInfo.value());
}
Hole 2:
[SCond,SLoop]: String path;
Hole 3:
[SCond,SLoop]: try
{
  path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
}
catch (Exception e)
{
  throw new RuntimeException("Failed to extract path from " + annotationType.getSimpleName() + " annotation on " + method.getName() + ".", e);
}
Hole 4:
[SCond,SLoop]: parsePath(path);
Hole 5:
[SCond,SLoop]: requestMethod = methodInfo.value();
Hole 6:
[SCond,SLoop]: requestHasBody = methodInfo.hasBody();
Hole 7:
[SCond,SLoop]: if (annotationType == Headers.class)
{
  String[] headersToParse = ((Headers) methodAnnotation).value();
  if (headersToParse.length == 0)
  {
    throw new IllegalStateException("Headers annotation was empty.");
  }
  headers = parseHeaders(headersToParse);
}
else
  if (annotationType == Multipart.class)
  {
    requestType = RequestType.MULTIPART;
  }
  else
    if (annotationType == FormEncoded.class)
    {
      requestType = RequestType.FORM_ENCODED;
    }
Hole 8:
[]: if (requestMethod == null)
{
  throw new IllegalStateException("Method " + method.getName() + " not annotated with request type (e.g., GET, POST).");
}
Hole 9:
[]: if (!requestHasBody)
{
  if (requestType == RequestType.MULTIPART)
  {
    throw new IllegalStateException("Multipart can only be specific on HTTP methods with request body (e.g., POST). (" + method.getName() + ")");
  }
  if (requestType == RequestType.FORM_ENCODED)
  {
    throw new IllegalStateException("Multipart can only be specific on HTTP methods with request body (e.g., POST). (" + method.getName() + ")");
  }
}
Hole 10:
[]: <SKIP>


