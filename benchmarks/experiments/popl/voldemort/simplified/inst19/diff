Parsing files...
Merge Instance for method (Ident "AdminClient",Ident "getReplicationMapping",[RefType (ClassRefType (ClassType [(Ident "Cluster",[])])),PrimType IntT,RefType (ClassRefType (ClassType [(Ident "RoutingStrategy",[])]))])
private Map<Integer, List<Integer>> getReplicationMapping (Cluster cluster, int nodeId, RoutingStrategy strategy)
{
  Node node = cluster.getNodeById(nodeId);
  Map<Integer, Integer> partitionsToNodeMapping = RebalanceUtils.getCurrentPartitionMapping(cluster);
  HashMap<Integer, List<Integer>> restoreMapping = new HashMap<Integer, List<Integer>>();
  for (int partition : node.getPartitionIds()) {
                                                 List<Integer> replicationPartitionsList = strategy.getReplicatingPartitionList(partition);
                                                 if (replicationPartitionsList.size() > 1)
                                                 {
                                                   int index = 0;
                                                   int replicatingPartition = replicationPartitionsList.get(index++);
                                                   while (partition == replicatingPartition)
                                                   {
                                                     replicatingPartition = replicationPartitionsList.get(index++);
                                                   }
                                                   int replicatingNode = partitionsToNodeMapping.get(replicatingPartition);
                                                   if (!restoreMapping.containsKey(replicatingNode))
                                                   {
                                                     restoreMapping.put(replicatingNode, new ArrayList<Integer>());
                                                   }
                                                   <?HOLE?>
                                                 }
                                               }
  <?HOLE?>
  return restoreMapping;
}
Edit Base:
Hole 1:
[SCond,SLoop]: restoreMapping.get(replicatingNode).add(partition);
Hole 2:
[]: logger.debug(("restore Node/Partition mapping:" + restoreMapping));

Edit A:
Hole 1:
[SCond,SLoop]: restoreMapping.get(replicatingNode).add(partition);
Hole 2:
[]: <SKIP>

Edit B:
Hole 1:
[SCond,SLoop]: if (!restoreMapping.get(replicatingNode).contains(replicatingPartition))
  restoreMapping.get(replicatingNode).add(replicatingPartition);
Hole 2:
[]: logger.debug(("restore Node/Partition mapping:" + restoreMapping));

Edit M:
Hole 1:
[SCond,SLoop]: if (!restoreMapping.get(replicatingNode).contains(replicatingPartition))
  restoreMapping.get(replicatingNode).add(replicatingPartition);
Hole 2:
[]: <SKIP>

Merge Instance for method (Ident "AdminClient",Ident "restoreStoreFromReplication",[PrimType IntT,RefType (ClassRefType (ClassType [(Ident "Cluster",[])])),RefType (ClassRefType (ClassType [(Ident "StoreDefinition",[])])),RefType (ClassRefType (ClassType [(Ident "ExecutorService",[])]))])
private void restoreStoreFromReplication (final int restoringNodeId, final Cluster cluster, final StoreDefinition storeDef, final ExecutorService executorService)
{
  logger.info(("Restoring data for store:" + storeDef.getName()));
  RoutingStrategyFactory factory = new RoutingStrategyFactory();
  RoutingStrategy strategy = factory.updateRoutingStrategy(storeDef, cluster);
  Map<Integer, List<Integer>> restoreMapping = getReplicationMapping(cluster, restoringNodeId, strategy);
  for (final Entry<Integer, List<Integer>> replicationEntry : restoreMapping.entrySet()) {
                                                                                           final int donorNodeId = replicationEntry.getKey();
                                                                                           <?HOLE?>
                                                                                         }
}
Edit Base:
Hole 1:
[SLoop]: executorService.submit(new Runnable()
                       {
                         public void run ()
                         {
                           try
                           {
                             logger.debug(("restoring data for store " + storeDef.getName() + " at node " + restoringNodeId + " from node " + replicationEntry.getKey() + " partitions:" + replicationEntry.getValue()));
                             int migrateAsyncId = migratePartitions(donorNodeId, restoringNodeId, storeDef.getName(), replicationEntry.getValue(), null);
                             waitForCompletion(restoringNodeId, migrateAsyncId, adminClientConfig.getRestoreDataTimeout(), TimeUnit.SECONDS);
                             logger.debug(("restoring data for store:" + storeDef.getName() + " from node " + donorNodeId + " completed."));
                           }
                           catch (Exception e)
                           {
                             logger.error(("restoring operation for store " + storeDef.getName() + " failed while copying from node " + donorNodeId), e);
                           }
                         }
                       });

Edit A:
Hole 1:
[SLoop]: executorService.submit(new Runnable()
                       {
                         public void run ()
                         {
                           try
                           {
                             logger.debug(("restoring data for store " + storeDef.getName() + " at node " + restoringNodeId + " from node " + replicationEntry.getKey() + " partitions:" + replicationEntry.getValue()));
                             int migrateAsyncId = migratePartitions(donorNodeId, restoringNodeId, storeDef.getName(), replicationEntry.getValue(), null);
                             waitForCompletion(restoringNodeId, migrateAsyncId, adminClientConfig.getRestoreDataTimeout(), TimeUnit.SECONDS);
                             logger.debug(("restoring data for store:" + storeDef.getName() + " from node " + donorNodeId + " completed."));
                           }
                           catch (Exception e)
                           {
                             logger.error(("restore operation for store " + storeDef.getName() + "from node " + donorNodeId + " failed."), e);
                           }
                         }
                       });

Edit B:
Hole 1:
[SLoop]: executorService.submit(new Runnable()
                       {
                         public void run ()
                         {
                           try
                           {
                             logger.info(("restoring data for store " + storeDef.getName() + " at node " + restoringNodeId + " from node " + replicationEntry.getKey() + " partitions:" + replicationEntry.getValue()));
                             int migrateAsyncId = migratePartitions(donorNodeId, restoringNodeId, storeDef.getName(), replicationEntry.getValue(), null);
                             waitForCompletion(restoringNodeId, migrateAsyncId, adminClientConfig.getRestoreDataTimeout(), TimeUnit.SECONDS);
                             logger.info(("restoring data for store:" + storeDef.getName() + " from node " + donorNodeId + " completed."));
                           }
                           catch (Exception e)
                           {
                             logger.error(("restoring operation for store " + storeDef.getName() + " failed while copying from node " + donorNodeId), e);
                           }
                         }
                       });

Edit M:
Hole 1:
[SLoop]: executorService.submit(new Runnable()
                       {
                         public void run ()
                         {
                           try
                           {
                             logger.info(("restoring data for store " + storeDef.getName() + " at node " + restoringNodeId + " from node " + replicationEntry.getKey() + " partitions:" + replicationEntry.getValue()));
                             int migrateAsyncId = migratePartitions(donorNodeId, restoringNodeId, storeDef.getName(), replicationEntry.getValue(), null);
                             waitForCompletion(restoringNodeId, migrateAsyncId, adminClientConfig.getRestoreDataTimeout(), TimeUnit.SECONDS);
                             logger.info(("restoring data for store:" + storeDef.getName() + " from node " + donorNodeId + " completed."));
                           }
                           catch (Exception e)
                           {
                             logger.error(("restore operation for store " + storeDef.getName() + "from node " + donorNodeId + " failed."), e);
                           }
                         }
                       });


