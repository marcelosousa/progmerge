Parsing files...
Merge Instance for method (Ident "RoutedStore",Ident "get",[RefType (ClassRefType (ClassType [(Ident "ByteArray",[])])),RefType (ClassRefType (ClassType [(Ident "StoreOp",[ActualType (ClassRefType (ClassType [(Ident "R",[])]))])])),RefType (ClassRefType (ClassType [(Ident "Function",[ActualType (ClassRefType (ClassType [(Ident "List",[ActualType (ClassRefType (ClassType [(Ident "GetResult",[ActualType (ClassRefType (ClassType [(Ident "R",[])]))])]))])])),ActualType (ClassRefType (ClassType [(Ident "Void",[])]))])]))])
private <R> List<R> get (final ByteArray key, StoreOp<R> fetcher, Function<List<GetResult<R>>, Void> preReturnProcedure) throws VoldemortException
{
  StoreUtils.assertValidKey(key);
  final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));
  checkRequiredReads(nodes);
  final List<GetResult<R>> retrieved = Lists.newArrayList();
  int successes = 0;
  final List<Throwable> failures = Lists.newArrayListWithCapacity(3);
  int attempts = Math.min(this.storeDef.getPreferredReads(), nodes.size());
  int nodeIndex = 0;
  List<Callable<GetResult<R>>> callables = Lists.newArrayListWithCapacity(attempts);
  for (; nodeIndex < attempts ; nodeIndex++)
  {
    final Node node = nodes.get(nodeIndex);
    callables.add(new GetCallable<R>(node, key, fetcher));
  }
  List<Future<GetResult<R>>> futures;
  try
  {
    futures = executor.invokeAll(callables, timeoutMs, TimeUnit.MILLISECONDS);
  }
  catch (InterruptedException e)
  {
    throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
  }
  for (Future<GetResult<R>> f : futures) {
                                           if (f.isCancelled())
                                           {
                                             logger.warn(("Get operation timed out after " + timeoutMs + " ms."));
                                             continue;
                                           }
                                           <?HOLE?>
                                         }
  while ((successes < this.storeDef.getPreferredReads() && nodeIndex) < nodes.size())
  {
    Node node = nodes.get(nodeIndex);
    <?HOLE?>
    nodeIndex++;
  }
  if (logger.isTraceEnabled())
    logger.trace(("GET retrieved the following node values: " + formatNodeValues(retrieved)));
  if (preReturnProcedure != null)
    preReturnProcedure.apply(retrieved);
  if (successes >= this.storeDef.getRequiredReads())
  {
    List<R> result = Lists.newArrayListWithExpectedSize(retrieved.size());
    for (GetResult<R> getResult : retrieved) result.addAll(getResult.retrieved);
    return result;
  }
  else
    throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads() + " reads required, but " + successes + " succeeded.", failures);
}
Edit Base:
Hole 1:
[SLoop]: try
{
  GetResult<R> getResult = f.get();
  if (getResult.exception != null)
  {
    failures.add(getResult.exception);
    continue;
  }
  ++successes;
  retrieved.add(getResult);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 2:
[SLoop]: try
{
  retrieved.add(new GetResult<R>(node, key, fetcher.execute(innerStores.get(node.getId()), key), null));
  ++successes;
  node.getStatus().setAvailable();
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  markUnavailable(node, e);
}
catch (Exception e)
{
  logger.warn(("Error in GET on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Edit A:
Hole 1:
[SLoop]: try
{
  GetResult<R> getResult = f.get();
  if (getResult.exception != null)
  {
    if (getResult.exception instanceof VoldemortApplicationException)
    {
      throw (VoldemortException) getResult.exception;
    }
    failures.add(getResult.exception);
    continue;
  }
  ++successes;
  retrieved.add(getResult);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 2:
[SLoop]: try
{
  retrieved.add(new GetResult<R>(node, key, fetcher.execute(innerStores.get(node.getId()), key), null));
  ++successes;
  node.getStatus().setAvailable();
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  markUnavailable(node, e);
}
catch (VoldemortApplicationException e)
{
  throw e;
}
catch (Exception e)
{
  logger.warn(("Error in GET on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Edit B:
Hole 1:
[SLoop]: try
{
  GetResult<R> getResult = f.get();
  if (getResult.exception != null)
  {
    failures.add(getResult.exception);
    continue;
  }
  ++successes;
  retrieved.add(getResult);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 2:
[SLoop]: try
{
  retrieved.add(new GetResult<R>(node, key, fetcher.execute(innerStores.get(node.getId()), key), null));
  ++successes;
  failureDetector.recordSuccess(node);
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  failureDetector.recordException(node, e);
}
catch (VoldemortApplicationException e)
{
  throw e;
}
catch (Exception e)
{
  logger.warn(("Error in GET on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Edit M:
Hole 1:
[SLoop]: try
{
  GetResult<R> getResult = f.get();
  if (getResult.exception != null)
  {
    if (getResult.exception instanceof VoldemortApplicationException)
    {
      throw (VoldemortException) getResult.exception;
    }
    failures.add(getResult.exception);
    continue;
  }
  ++successes;
  retrieved.add(getResult);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 2:
[SLoop]: try
{
  retrieved.add(new GetResult<R>(node, key, fetcher.execute(innerStores.get(node.getId()), key), null));
  ++successes;
  failureDetector.recordSuccess(node);
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  failureDetector.recordException(node, e);
}
catch (VoldemortApplicationException e)
{
  throw e;
}
catch (Exception e)
{
  logger.warn(("Error in GET on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Merge Instance for method (Ident "RoutedStore",Ident "getAll",[RefType (ClassRefType (ClassType [(Ident "Iterable",[ActualType (ClassRefType (ClassType [(Ident "ByteArray",[])]))])]))])
public Map<ByteArray, List<Versioned<byte[]>>> getAll (Iterable<ByteArray> keys) throws VoldemortException
{
  StoreUtils.assertValidKeys(keys);
  Map<ByteArray, List<Versioned<byte[]>>> result = StoreUtils.newEmptyHashMap(keys);
  Map<Node, List<ByteArray>> nodeToKeysMap = Maps.newHashMap();
  Map<ByteArray, List<Node>> keyToExtraNodesMap = Maps.newHashMap();
  for (ByteArray key : keys) {
                               List<Node> availableNodes = availableNodes(routingStrategy.routeRequest(key.get()));
                               checkRequiredReads(availableNodes);
                               int preferredReads = storeDef.getPreferredReads();
                               List<Node> preferredNodes = Lists.newArrayListWithCapacity(preferredReads);
                               List<Node> extraNodes = Lists.newArrayListWithCapacity(3);
                               for (Node node : availableNodes) {
                                                                  if (preferredNodes.size() < preferredReads)
                                                                    preferredNodes.add(node);
                                                                  else
                                                                    extraNodes.add(node);
                                                                }
                               for (Node node : preferredNodes) {
                                                                  List<ByteArray> nodeKeys = nodeToKeysMap.get(node);
                                                                  if (nodeKeys == null)
                                                                  {
                                                                    nodeKeys = Lists.newArrayList();
                                                                    nodeToKeysMap.put(node, nodeKeys);
                                                                  }
                                                                  nodeKeys.add(key);
                                                                }
                               if (!extraNodes.isEmpty())
                               {
                                 List<Node> nodes = keyToExtraNodesMap.get(key);
                                 if (nodes == null)
                                   keyToExtraNodesMap.put(key, extraNodes);
                                 else
                                   nodes.addAll(extraNodes);
                               }
                             }
  List<Callable<GetAllResult>> callables = Lists.newArrayList();
  for (Map.Entry<Node, List<ByteArray>> entry : nodeToKeysMap.entrySet()) {
                                                                            final Node node = entry.getKey();
                                                                            final Collection<ByteArray> nodeKeys = entry.getValue();
                                                                            <?HOLE?>
                                                                          }
  List<Throwable> failures = Lists.newArrayList();
  List<NodeValue<ByteArray, byte[]>> nodeValues = Lists.newArrayList();
  Map<ByteArray, MutableInt> keyToSuccessCount = Maps.newHashMap();
  for (ByteArray key : keys) keyToSuccessCount.put(key, new MutableInt(0));
  List<Future<GetAllResult>> futures;
  try
  {
    futures = executor.invokeAll(callables, (timeoutMs * 3), TimeUnit.MILLISECONDS);
  }
  catch (InterruptedException e)
  {
    throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
  }
  for (Future<GetAllResult> f : futures) {
                                           if (f.isCancelled())
                                           {
                                             logger.warn(("Get operation timed out after " + timeoutMs + " ms."));
                                             continue;
                                           }
                                           <?HOLE?>
                                         }
  for (ByteArray key : keys) {
                               MutableInt successCountWrapper = keyToSuccessCount.get(key);
                               int successCount = successCountWrapper.intValue();
                               if (successCount < storeDef.getPreferredReads())
                               {
                                 List<Node> extraNodes = keyToExtraNodesMap.get(key);
                                 if (extraNodes != null)
                                 {
                                   for (Node node : extraNodes) {
                                                                  <?HOLE?>
                                                                }
                                 }
                               }
                               successCountWrapper.setValue(successCount);
                             }
  repairReads(nodeValues);
  for (Map.Entry<ByteArray, MutableInt> mapEntry : keyToSuccessCount.entrySet()) {
                                                                                   int successCount = mapEntry.getValue().intValue();
                                                                                   if (successCount < storeDef.getRequiredReads())
                                                                                     throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads() + " reads required, but " + successCount + " succeeded.", failures);
                                                                                 }
  return result;
}
Edit Base:
Hole 1:
[SCond,SLoop]: if (isAvailable(node))
  callables.add(new GetAllCallable(node, nodeKeys));
Hole 2:
[SLoop]: try
{
  GetAllResult getResult = f.get();
  if (getResult.exception != null)
  {
    failures.add(getResult.exception);
    continue;
  }
  for (ByteArray key : getResult.callable.nodeKeys) {
                                                      List<Versioned<byte[]>> retrieved = getResult.retrieved.get(key);
                                                      MutableInt successCount = keyToSuccessCount.get(key);
                                                      successCount.increment();
                                                      if (retrieved != null)
                                                      {
                                                        List<Versioned<byte[]>> existing = result.get(key);
                                                        if (existing == null)
                                                          result.put(key, Lists.newArrayList(retrieved));
                                                        else
                                                          existing.addAll(retrieved);
                                                      }
                                                    }
  nodeValues.addAll(getResult.nodeValues);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 3:
[SLoop,SCond,SCond,SLoop]: try
{
  List<Versioned<byte[]>> values = innerStores.get(node.getId()).get(key);
  fillRepairReadsValues(nodeValues, key, node, values);
  List<Versioned<byte[]>> versioneds = result.get(key);
  if (versioneds == null)
    result.put(key, Lists.newArrayList(values));
  else
    versioneds.addAll(values);
  node.getStatus().setAvailable();
  if (++successCount >= storeDef.getPreferredReads())
    break;
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  markUnavailable(node, e);
}
catch (Exception e)
{
  logger.warn(("Error in GET_ALL on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Edit A:
Hole 1:
[SCond,SLoop]: if (isAvailable(node))
  callables.add(new GetAllCallable(node, nodeKeys));
Hole 2:
[SLoop]: try
{
  GetAllResult getResult = f.get();
  if (getResult.exception != null)
  {
    if (getResult.exception instanceof VoldemortApplicationException)
    {
      throw (VoldemortException) getResult.exception;
    }
    failures.add(getResult.exception);
    continue;
  }
  for (ByteArray key : getResult.callable.nodeKeys) {
                                                      List<Versioned<byte[]>> retrieved = getResult.retrieved.get(key);
                                                      MutableInt successCount = keyToSuccessCount.get(key);
                                                      successCount.increment();
                                                      if (retrieved != null)
                                                      {
                                                        List<Versioned<byte[]>> existing = result.get(key);
                                                        if (existing == null)
                                                          result.put(key, Lists.newArrayList(retrieved));
                                                        else
                                                          existing.addAll(retrieved);
                                                      }
                                                    }
  nodeValues.addAll(getResult.nodeValues);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 3:
[SLoop,SCond,SCond,SLoop]: try
{
  List<Versioned<byte[]>> values = innerStores.get(node.getId()).get(key);
  fillRepairReadsValues(nodeValues, key, node, values);
  List<Versioned<byte[]>> versioneds = result.get(key);
  if (versioneds == null)
    result.put(key, Lists.newArrayList(values));
  else
    versioneds.addAll(values);
  node.getStatus().setAvailable();
  if (++successCount >= storeDef.getPreferredReads())
    break;
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  markUnavailable(node, e);
}
catch (VoldemortApplicationException e)
{
  throw e;
}
catch (Exception e)
{
  logger.warn(("Error in GET_ALL on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Edit B:
Hole 1:
[SCond,SLoop]: if (failureDetector.isAvailable(node))
  callables.add(new GetAllCallable(node, nodeKeys));
Hole 2:
[SLoop]: try
{
  GetAllResult getResult = f.get();
  if (getResult.exception != null)
  {
    failures.add(getResult.exception);
    continue;
  }
  for (ByteArray key : getResult.callable.nodeKeys) {
                                                      List<Versioned<byte[]>> retrieved = getResult.retrieved.get(key);
                                                      MutableInt successCount = keyToSuccessCount.get(key);
                                                      successCount.increment();
                                                      if (retrieved != null)
                                                      {
                                                        List<Versioned<byte[]>> existing = result.get(key);
                                                        if (existing == null)
                                                          result.put(key, Lists.newArrayList(retrieved));
                                                        else
                                                          existing.addAll(retrieved);
                                                      }
                                                    }
  nodeValues.addAll(getResult.nodeValues);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 3:
[SLoop,SCond,SCond,SLoop]: try
{
  List<Versioned<byte[]>> values = innerStores.get(node.getId()).get(key);
  fillRepairReadsValues(nodeValues, key, node, values);
  List<Versioned<byte[]>> versioneds = result.get(key);
  if (versioneds == null)
    result.put(key, Lists.newArrayList(values));
  else
    versioneds.addAll(values);
  failureDetector.recordSuccess(node);
  if (++successCount >= storeDef.getPreferredReads())
    break;
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  failureDetector.recordException(node, e);
}
catch (VoldemortApplicationException e)
{
  throw e;
}
catch (Exception e)
{
  logger.warn(("Error in GET_ALL on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}

Edit M:
Hole 1:
[SLoop]: if (failureDetector.isAvailable(node))
  callables.add(new GetAllCallable(node, nodeKeys));
Hole 2:
[SLoop]: try
{
  GetAllResult getResult = f.get();
  if (getResult.exception != null)
  {
    if (getResult.exception instanceof VoldemortApplicationException)
    {
      throw (VoldemortException) getResult.exception;
    }
    failures.add(getResult.exception);
    continue;
  }
  for (ByteArray key : getResult.callable.nodeKeys) {
                                                      List<Versioned<byte[]>> retrieved = getResult.retrieved.get(key);
                                                      MutableInt successCount = keyToSuccessCount.get(key);
                                                      successCount.increment();
                                                      if (retrieved != null)
                                                      {
                                                        List<Versioned<byte[]>> existing = result.get(key);
                                                        if (existing == null)
                                                          result.put(key, Lists.newArrayList(retrieved));
                                                        else
                                                          existing.addAll(retrieved);
                                                      }
                                                    }
  nodeValues.addAll(getResult.nodeValues);
}
catch (InterruptedException e)
{
  throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
}
catch (ExecutionException e)
{
  if (e.getCause() instanceof Error)
    throw (Error) e.getCause();
  else
    logger.error(e.getMessage(), e);
}
Hole 3:
[SLoop,SCond,SCond,SLoop]: try
{
  List<Versioned<byte[]>> values = innerStores.get(node.getId()).get(key);
  fillRepairReadsValues(nodeValues, key, node, values);
  List<Versioned<byte[]>> versioneds = result.get(key);
  if (versioneds == null)
    result.put(key, Lists.newArrayList(values));
  else
    versioneds.addAll(values);
  failureDetector.recordSuccess(node);
  if (++successCount >= storeDef.getPreferredReads())
    break;
}
catch (UnreachableStoreException e)
{
  failures.add(e);
  failureDetector.recordException(node, e);
}
catch (VoldemortApplicationException e)
{
  throw e;
}
catch (Exception e)
{
  logger.warn(("Error in GET_ALL on node " + node.getId() + "(" + node.getHost() + ")"), e);
  failures.add(e);
}


