Parsing files...
Merge Instance for method (Ident "RoutedStoreTest",Ident "testPutTimeout",[])
@Test
 public void testPutTimeout () throws Exception
{
  int timeout = 50;
  StoreDefinition definition = new StoreDefinitionBuilder().setName("test").setType("foo").setKeySerializer(new SerializerDefinition("test")).setValueSerializer(new SerializerDefinition("test")).setRoutingPolicy(RoutingTier.CLIENT).setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY).setReplicationFactor(3).setPreferredReads(3).setRequiredReads(3).setPreferredWrites(3).setRequiredWrites(3).build();
  <?HOLE?>
  List<Node> nodes = new ArrayList<Node>();
  int totalDelay = 0;
  for (int i = 0 ; i < 3 ; i++)
  {
    int delay = (4 + i) * timeout;
    totalDelay += delay;
    <?HOLE?>
    stores.put(i, store);
    List<Integer> partitions = Arrays.asList(i);
    nodes.add(new Node(i, "none", 0, 0, 0, partitions));
  }
  setFailureDetector(stores);
  routedStoreThreadPool = Executors.newFixedThreadPool(3);
  RoutedStoreFactory routedStoreFactory = new RoutedStoreFactory(isPipelineRoutedStoreEnabled, routedStoreThreadPool, timeout);
  RoutedStore routedStore = routedStoreFactory.create(new Cluster("test", nodes), definition, stores, true, failureDetector);
  <?HOLE?>
  <?HOLE?>
}
Edit Base:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[]> store = new SleepyStore<ByteArray, byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[]>("test"));
Hole 3:
[]: long start = System.currentTimeMillis();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }));
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = System.currentTimeMillis() - start;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Edit A:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[], byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[], byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[], byte[]> store = new SleepyStore<ByteArray, byte[], byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[], byte[]>("test"));
Hole 3:
[]: long start = System.currentTimeMillis();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }), null);
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = System.currentTimeMillis() - start;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Edit B:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[]> store = new SleepyStore<ByteArray, byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[]>("test"));
Hole 3:
[]: long start = System.nanoTime();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }));
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = (System.nanoTime() - start) / Time.NS_PER_MS;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}

Edit M:
Hole 1:
[]: Map<Integer, Store<ByteArray, byte[], byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[], byte[]>>();
Hole 2:
[SLoop]: Store<ByteArray, byte[], byte[]> store = new SleepyStore<ByteArray, byte[], byte[]>(delay, new InMemoryStorageEngine<ByteArray, byte[], byte[]>("test"));
Hole 3:
[]: long start = System.nanoTime();
Hole 4:
[]: try
{
  routedStore.put(new ByteArray("test".getBytes()), new Versioned<byte[]>(new byte[] {
                                                                                       1,
                                                                                     }), null);
  fail("Should have thrown");
}
catch (InsufficientOperationalNodesException e)
{
  long elapsed = (System.nanoTime() - start) / Time.NS_PER_MS;
  assertTrue((elapsed + " < " + totalDelay), (elapsed < totalDelay));
}


